apiVersion: v1
kind: Secret
metadata:
  name: xorb-database-credentials
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
  annotations:
    secret.reloader.stakater.com/reload: "xorb-orchestrator"
type: Opaque
stringData:
  POSTGRES_USER: "xorb_secure_user"
  POSTGRES_PASSWORD: "CHANGE_ME_IN_PRODUCTION"  # Will be replaced by external secret management
  POSTGRES_DB: "xorb_secure_db"
  REDIS_PASSWORD: "CHANGE_ME_IN_PRODUCTION"
---
apiVersion: v1
kind: Secret
metadata:
  name: xorb-api-keys
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
  annotations:
    secret.reloader.stakater.com/reload: "xorb-orchestrator"
type: Opaque
stringData:
  OPENAI_API_KEY: "CHANGE_ME_IN_PRODUCTION"
  HACKERONE_API_TOKEN: "CHANGE_ME_IN_PRODUCTION"
  NEO4J_PASSWORD: "CHANGE_ME_IN_PRODUCTION"
  PROMETHEUS_TOKEN: "CHANGE_ME_IN_PRODUCTION"
---
apiVersion: v1
kind: Secret
metadata:
  name: xorb-tls-certificates
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
type: kubernetes.io/tls
stringData:
  tls.crt: |
    -----BEGIN CERTIFICATE-----
    # This would contain the actual TLS certificate
    # In production, use cert-manager or external certificate management
    -----END CERTIFICATE-----
  tls.key: |
    -----BEGIN PRIVATE KEY-----
    # This would contain the actual private key
    # In production, use cert-manager or external certificate management
    -----END PRIVATE KEY-----
---
# External Secrets Operator configuration (if using external secret management)
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: xorb-vault-secret-store
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
spec:
  provider:
    vault:
      server: "https://vault.internal.company.com"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "xorb-secret-reader"
          serviceAccountRef:
            name: "xorb-vault-auth"
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: xorb-external-database-credentials
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
spec:
  refreshInterval: 15m
  secretStoreRef:
    name: xorb-vault-secret-store
    kind: SecretStore
  target:
    name: xorb-database-credentials-external
    creationPolicy: Owner
  data:
  - secretKey: POSTGRES_USER
    remoteRef:
      key: xorb/database
      property: username
  - secretKey: POSTGRES_PASSWORD
    remoteRef:
      key: xorb/database
      property: password
  - secretKey: POSTGRES_DB
    remoteRef:
      key: xorb/database
      property: database
  - secretKey: REDIS_PASSWORD
    remoteRef:
      key: xorb/redis
      property: password
---
# Service Account for external secret management
apiVersion: v1
kind: ServiceAccount
metadata:
  name: xorb-vault-auth
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
---
# RBAC for external secret management
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: xorb-vault-auth
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch"]
- apiGroups: [""]
  resources: ["serviceaccounts/token"]  
  verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: xorb-vault-auth
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: xorb-vault-auth
subjects:
- kind: ServiceAccount
  name: xorb-vault-auth
  namespace: xorb-prod
---
# Sealed Secrets configuration (alternative to External Secrets)
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: xorb-sealed-database-credentials
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
spec:
  encryptedData:
    # These would be encrypted using kubeseal CLI
    # Example: echo -n "actual_password" | kubeseal --raw --from-file=/dev/stdin --name=xorb-sealed-database-credentials --namespace=xorb-prod
    POSTGRES_USER: AgBy3i4OJSWK+PiTySYZZA9rO4s... # Encrypted with kubeseal
    POSTGRES_PASSWORD: AgAh5CvY2ZJN8l2g+KJh1AqO... # Encrypted with kubeseal
    POSTGRES_DB: AgCEKVK5HdE8j2Nq4l+GJqH1... # Encrypted with kubeseal
    REDIS_PASSWORD: AgDKE2l5HdE8j2Nq4l+GJqH1... # Encrypted with kubeseal
  template:
    metadata:
      name: xorb-sealed-database-credentials
      namespace: xorb-prod
      labels:
        app.kubernetes.io/name: xorb
        app.kubernetes.io/component: security
    type: Opaque
---
# Secret rotation configuration
apiVersion: batch/v1
kind: CronJob
metadata:
  name: xorb-secret-rotation
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
spec:
  schedule: "0 2 1 * *"  # Monthly on 1st at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: xorb-secret-rotator
          restartPolicy: OnFailure
          containers:
          - name: secret-rotator
            image: xorb/secret-rotator:latest
            command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "Starting secret rotation process..."
              
              # Rotate database passwords
              NEW_POSTGRES_PASSWORD=$(openssl rand -base64 32)
              NEW_REDIS_PASSWORD=$(openssl rand -base64 32)
              
              # Update secrets in Kubernetes
              kubectl create secret generic xorb-database-credentials-new \
                --from-literal=POSTGRES_USER="${POSTGRES_USER}" \
                --from-literal=POSTGRES_PASSWORD="${NEW_POSTGRES_PASSWORD}" \
                --from-literal=POSTGRES_DB="${POSTGRES_DB}" \
                --from-literal=REDIS_PASSWORD="${NEW_REDIS_PASSWORD}" \
                --namespace=xorb-prod
              
              # Update database with new password
              PGPASSWORD="${CURRENT_POSTGRES_PASSWORD}" psql -h postgres -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" \
                -c "ALTER USER ${POSTGRES_USER} PASSWORD '${NEW_POSTGRES_PASSWORD}';"
              
              # Update Redis password (if authentication is enabled)
              redis-cli -h redis -a "${CURRENT_REDIS_PASSWORD}" CONFIG SET requirepass "${NEW_REDIS_PASSWORD}"
              
              # Replace old secret with new one
              kubectl delete secret xorb-database-credentials --namespace=xorb-prod
              kubectl patch secret xorb-database-credentials-new \
                -p '{"metadata":{"name":"xorb-database-credentials"}}' \
                --type=merge --namespace=xorb-prod
              
              # Restart affected deployments to pick up new secrets
              kubectl rollout restart deployment/xorb-orchestrator --namespace=xorb-prod
              
              echo "Secret rotation completed successfully"
            env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: xorb-database-credentials
                  key: POSTGRES_USER
            - name: CURRENT_POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: xorb-database-credentials
                  key: POSTGRES_PASSWORD
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: xorb-database-credentials
                  key: POSTGRES_DB
            - name: CURRENT_REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: xorb-database-credentials
                  key: REDIS_PASSWORD
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 500m
                memory: 256Mi
---
# Service Account for secret rotation
apiVersion: v1
kind: ServiceAccount
metadata:
  name: xorb-secret-rotator
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: xorb-secret-rotator
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments/rollout"]
  verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: xorb-secret-rotator
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: xorb-secret-rotator
subjects:
- kind: ServiceAccount
  name: xorb-secret-rotator
  namespace: xorb-prod
---
# Secret scanning configuration using Falco
apiVersion: v1
kind: ConfigMap
metadata:
  name: xorb-falco-secret-rules
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: xorb
    app.kubernetes.io/component: security
data:
  secret_detection_rules.yaml: |
    - rule: Xorb Secret Access in Container
      desc: Detect when secrets are accessed in Xorb containers
      condition: >
        spawned_process and
        container and
        k8s.ns.name = "xorb-prod" and
        (proc.name in (cat, grep, awk, sed) and
         (proc.args contains "POSTGRES_PASSWORD" or 
          proc.args contains "REDIS_PASSWORD" or
          proc.args contains "API_KEY"))
      output: >
        Secret potentially exposed in Xorb container 
        (user=%user.name command=%proc.cmdline container=%container.name 
         namespace=%k8s.ns.name pod=%k8s.pod.name)
      priority: WARNING
      tags: [secrets, xorb, security]

    - rule: Xorb Unauthorized Secret Mount
      desc: Detect unauthorized secret mounts in Xorb namespace
      condition: >
        k8s_audit and
        ka.verb in (create, update, patch) and
        ka.target.resource = "pods" and
        ka.target.namespace = "xorb-prod" and
        ka.request_object contains "secret" and
        not ka.user.name in (system:serviceaccount:xorb-prod:xorb-orchestrator,
                            system:serviceaccount:xorb-prod:xorb-secret-rotator)
      output: >
        Unauthorized secret mount in Xorb namespace
        (user=%ka.user.name pod=%ka.target.name namespace=%ka.target.namespace)
      priority: HIGH
      tags: [secrets, k8s, xorb, security]

    - rule: Xorb Secret Exfiltration Attempt
      desc: Detect potential secret exfiltration from Xorb containers
      condition: >
        spawned_process and
        container and
        k8s.ns.name = "xorb-prod" and
        proc.name in (curl, wget, nc, telnet) and
        (proc.args contains "secret" or
         proc.args contains "password" or
         proc.args contains "token")
      output: >
        Potential secret exfiltration from Xorb container
        (user=%user.name command=%proc.cmdline container=%container.name 
         pod=%k8s.pod.name)
      priority: CRITICAL
      tags: [secrets, exfiltration, xorb, security]