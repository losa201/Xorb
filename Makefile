# Xorb developer Makefile

.PHONY: help api orchestrator ptass up down test lint fmt token security-scan precommit-install sanitize-history integration-test integration-up integration-down backplane-lint nats-iac-plan nats-iac-apply nats-iac-destroy nats-test-isolation nats-generate-creds replay-plan replay-drill replay-validate replay-infrastructure replay-dashboard replay-runbook obs-instrument obs-dashboards obs-validate obs-report obs-test-alerts g6-tenant-plan g6-tenant-apply g6-tenant-test g6-tenant-validate g7-evidence-setup g7-evidence-test g7-merkle-rollup g7-verify-rollup sdks-test

help:
	@echo "Development Commands:"
	@echo "make up         - docker compose up for dev"
	@echo "make down       - docker compose down"
	@echo "make api        - run API locally (requires venv)"
	@echo "make orchestrator - run orchestrator locally (requires venv)"
	@echo "make test       - run pytest for API"
	@echo ""
	@echo "Security & Compliance:"
	@echo "make guardrails-verify  - run all security guardrails checks"
	@echo "make sbom               - generate Software Bill of Materials"
	@echo "make sign               - sign artifacts (dry-run)"
	@echo "make slis-serve         - start SLI metrics server"
	@echo "make security-full      - run comprehensive security scan"
	@echo ""
	@echo "Backplane Operations (Phase G2):"
	@echo "make backplane-lint     - validate NATS subject schema compliance"
	@echo "make nats-iac-plan      - plan NATS infrastructure changes"
	@echo "make nats-iac-apply     - apply NATS infrastructure"
	@echo "make nats-iac-destroy   - destroy NATS infrastructure"
	@echo "make nats-test-isolation - test tenant isolation"
	@echo "make nats-generate-creds - generate tenant credentials"
	@echo ""
	@echo "Replay-Safe Streaming (Phase G4):"
	@echo "make replay-plan        - plan replay infrastructure diff"
	@echo "make replay-drill       - execute chaos drill (10x load)"
	@echo "make replay-validate    - validate SLO compliance"
	@echo "make replay-infrastructure - deploy replay infrastructure"
	@echo "make replay-dashboard   - launch Grafana replay dashboard"
	@echo "make replay-runbook     - display incident response runbook"
	@echo ""
	@echo "Observability & SLOs (Phase G5):"
	@echo "make obs-instrument     - initialize G5 observability instrumentation"
	@echo "make obs-dashboards     - provision Grafana SLO dashboards"
	@echo "make obs-validate       - validate SLO configuration"
	@echo "make obs-report         - generate SLO compliance report"
	@echo "make obs-test-alerts    - test error budget alert rules"
	@echo ""
	@echo "Tenant-Isolated Backplane (Phase G6):"
	@echo "make g6-tenant-plan     - plan G6 tenant isolation infrastructure"
	@echo "make g6-tenant-apply    - apply G6 tenant accounts with quotas"
	@echo "make g6-tenant-test     - run tenant isolation validation tests"
	@echo "make g6-tenant-validate - validate tenant isolation (live test)"
	@echo ""
	@echo "Provable Evidence v1 (Phase G7):"
	@echo "make g7-evidence-setup  - setup G7 cryptographic evidence infrastructure"
	@echo "make g7-evidence-test   - test evidence creation and verification"
	@echo "make g7-merkle-rollup   - create weekly Merkle tree roll-up"
	@echo "make g7-verify-rollup   - verify evidence inclusion in roll-up"

up:
	docker compose -f deploy/configs/docker-compose.dev.yml up --build

down:
	docker compose -f deploy/configs/docker-compose.dev.yml down

api:
	cd src/api && uvicorn app.main:app --reload --port 8000

orchestrator:
	cd src/orchestrator && python main.py

test:
	pytest -q

token:
	@echo "Requesting dev token (ensure DEV_MODE=true)"
	@curl -s -X POST http://localhost:8000/auth/dev-token | jq -r .access_token

precommit-install: ## Install pre-commit hooks
	@pre-commit install -f

security-scan: ## Run gitleaks scan locally
	@gitleaks detect --source . --no-banner --redact --config .gitleaks.toml || true

sanitize-history: ## Rewrite git history to remove secrets
	@bash tools/secrets/remediate_git_history.sh

# --- Integration Test Targets ---
integration-test: ## Run integration tests
	@pytest -xvs tests/integration/

integration-up: ## Start local NATS JetStream server for integration tests (placeholder)
	@echo "Starting local NATS JetStream server..."
	@echo "Note: This target is a placeholder. The test suite manages NATS lifecycle."
	@echo "To run tests, use 'make integration-test'."

integration-down: ## Stop local NATS JetStream server for integration tests (placeholder)
	@echo "Stopping local NATS JetStream server..."
	@echo "Note: This target is a placeholder. The test suite manages NATS lifecycle."

# --- Guardrails and Security Targets ---
guardrails-verify: ## Run all security guardrails checks
	@echo "üîí Running repository guardrails verification..."
	@echo "üìã Checking pre-commit hooks..."
	@pre-commit run --all-files || { echo "‚ùå Pre-commit hooks failed"; exit 1; }
	@echo "üîç Running gitleaks secret detection..."
	@gitleaks detect --source . --no-banner --redact || { echo "‚ùå Secrets detected"; exit 1; }
	@echo "üõ°Ô∏è Checking for HS256 usage..."
	@! grep -r --include="*.py" --include="*.js" --include="*.ts" --include="*.json" --include="*.yaml" --include="*.yml" "\bHS256\b" . --exclude-dir=.git --exclude-dir=venv --exclude-dir=.venv --exclude-dir=node_modules || { echo "‚ùå HS256 usage detected"; exit 1; }
	@echo "üì° Checking for Redis bus usage..."
	@! grep -r --include="*.py" --include="*.js" --include="*.ts" "\b(redis\.(pubsub|subscribe|psubscribe)|redis\.client\.PubSub)\b" . --exclude-dir=.git --exclude-dir=venv --exclude-dir=.venv --exclude-dir=node_modules || { echo "‚ùå Redis bus usage detected"; exit 1; }
	@echo "üîê Checking TLS configurations..."
	@! grep -r --include="*.conf" --include="*.yaml" --include="*.yml" --include="*.json" --include="*.py" "(ssl_protocols|tls_version|TLSv1\.[0-2])" . --exclude-dir=.git --exclude-dir=venv --exclude-dir=.venv || { echo "‚ùå Legacy TLS detected"; exit 1; }
	@echo "‚úÖ All guardrails checks passed"

sbom: ## Generate Software Bill of Materials
	@echo "üìã Generating SBOM..."
	@./tools/scripts/syft_cosign.sh sbom

sign: ## Sign artifacts with Cosign (dry-run by default)
	@echo "‚úçÔ∏è Signing artifacts..."
	@DRY_RUN=true ./tools/scripts/syft_cosign.sh full

slis-serve: ## Start SLI metrics server
	@echo "üìä Starting SLI metrics server..."
	@cd src/xorb_platform/observability && python3 metrics.py --simulate --host 0.0.0.0 --port 9090

# --- Security scanning targets ---
security-full: ## Run comprehensive security scan
	@echo "üîç Running comprehensive security scan..."
	@./tools/scripts/security-scan.sh || echo "‚ö†Ô∏è Security scan completed with warnings"

# --- Backplane Operations (Phase G2) ---
backplane-lint: ## Validate NATS subject schema compliance (v1 immutable)
	@echo "üîç Validating NATS subject schema compliance..."
	@echo "Schema: xorb.<tenant>.<domain>.<service>.<event>"
	@python3 tools/backplane/subject_lint.py --schema
	@echo ""
	@echo "Scanning source code for violations..."
	@python3 tools/backplane/subject_lint.py --paths src/ services/ xorb_platform_bus/ tests/ tools/ infra/ \
		--allowlist "invalid|SCAN|CREATED|started|scanning|tenant-√±|tenant@|ab\.|t\.|README\.md" || { \
		echo "‚ùå Subject schema violations found!"; \
		echo "Fix violations to comply with v1 schema."; \
		exit 1; \
	}
	@echo "‚úÖ All NATS subjects comply with v1 schema"

nats-iac-plan: ## Plan NATS infrastructure changes with Terraform
	@echo "üìã Planning NATS infrastructure changes..."
	@cd infra/iac/nats && terraform init -upgrade
	@cd infra/iac/nats && terraform plan -var-file="environments/dev.tfvars" -out=tfplan 2>/dev/null || { \
		echo "Using default variables (dev.tfvars not found)..."; \
		terraform plan -out=tfplan; \
	}
	@echo "‚úÖ Terraform plan completed. Review tfplan file."

nats-iac-apply: ## Apply NATS infrastructure (requires credentials)
	@echo "üöÄ Applying NATS infrastructure..."
	@if [ ! -f "infra/iac/nats/tfplan" ]; then \
		echo "‚ùå No terraform plan found. Run 'make nats-iac-plan' first."; \
		exit 1; \
	fi
	@cd infra/iac/nats && terraform apply tfplan
	@echo "‚úÖ NATS infrastructure deployed successfully"
	@echo "üìÑ Configuration files generated in infra/iac/nats/out/"

nats-iac-destroy: ## Destroy NATS infrastructure (DESTRUCTIVE)
	@echo "‚ö†Ô∏è  WARNING: This will destroy ALL NATS infrastructure!"
	@echo "This includes accounts, streams, consumers, and data."
	@read -p "Type 'DESTROY' to confirm: " confirm && [ "$$confirm" = "DESTROY" ] || { \
		echo "‚ùå Destruction cancelled."; \
		exit 1; \
	}
	@cd infra/iac/nats && terraform destroy -auto-approve
	@echo "üí• NATS infrastructure destroyed"

nats-test-isolation: ## Test tenant isolation (requires NATS server)
	@echo "üß™ Testing tenant isolation..."
	@echo "Starting NATS server for testing..."
	@nats-server -js -p 14222 -sd /tmp/nats-test-store &
	@NATS_PID=$$!; \
	sleep 2; \
	echo "Running isolation tests..."; \
	python3 -c " \
import asyncio; \
from xorb_platform_bus.bus.pubsub.nats_client import create_nats_client, Domain, Event; \
async def test(): \
    print('Testing tenant A...'); \
    client_a = create_nats_client('tenant-a', ['nats://localhost:14222']); \
    async with client_a.connection(): \
        await client_a.publish(Domain.SCAN, 'test', Event.CREATED, {'data': 'from-a'}); \
        print('‚úÖ Tenant A can publish to own subjects'); \
    print('Testing tenant B...'); \
    client_b = create_nats_client('tenant-b', ['nats://localhost:14222']); \
    async with client_b.connection(): \
        await client_b.publish(Domain.SCAN, 'test', Event.CREATED, {'data': 'from-b'}); \
        print('‚úÖ Tenant B can publish to own subjects'); \
    print('‚úÖ Tenant isolation test passed'); \
asyncio.run(test()) \
" || { echo "‚ùå Isolation test failed"; kill $$NATS_PID; exit 1; }; \
	kill $$NATS_PID; \
	echo "üßπ Cleaning up test server..."
	@echo "‚úÖ Tenant isolation verified"

nats-generate-creds: ## Generate NATS credentials for tenants
	@echo "üîë Generating NATS credentials..."
	@if [ ! -f "infra/iac/nats/out/tenant-t-qa-config.json" ]; then \
		echo "‚ùå No tenant configurations found. Run 'make nats-iac-apply' first."; \
		exit 1; \
	fi
	@echo "üìÅ Available tenant configurations:"
	@ls -1 infra/iac/nats/out/tenant-*-config.json 2>/dev/null | sed 's/.*tenant-\(.*\)-config.json/  \1/' || echo "  (none found)"
	@echo ""
	@echo "üîê Sample credential usage:"
	@echo "export NATS_CREDENTIALS=/path/to/tenant-credentials.creds"
	@echo "nats pub --creds=\$$NATS_CREDENTIALS 'xorb.tenant-1.scan.nmap.created' 'test'"
	@echo ""
	@echo "‚úÖ Use configuration files in infra/iac/nats/out/ for integration"

# =====================================
# Phase G8 Control Plane Targets
# =====================================

g8-control-plane-init: ## Initialize G8 Control Plane with default tenants
	@echo "üéõÔ∏è Initializing G8 Control Plane (WFQ + Quotas)..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py create-tenant t-enterprise enterprise
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py create-tenant t-professional professional  
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py create-tenant t-starter starter
	@echo "‚úÖ Control Plane initialized with 3 tenant tiers"

g8-control-plane-status: ## Get comprehensive control plane status
	@echo "üìä Getting G8 Control Plane system status..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py system-status

g8-tenant-status: ## Get detailed tenant status (requires TENANT_ID)
	@if [ -z "$(TENANT_ID)" ]; then \
		echo "‚ùå Please specify TENANT_ID: make g8-tenant-status TENANT_ID=t-enterprise"; \
		exit 1; \
	fi
	@echo "üìä Getting status for tenant $(TENANT_ID)..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py tenant-status $(TENANT_ID)

g8-submit-request: ## Submit test resource request (requires TENANT_ID, RESOURCE_TYPE)
	@if [ -z "$(TENANT_ID)" ] || [ -z "$(RESOURCE_TYPE)" ]; then \
		echo "‚ùå Usage: make g8-submit-request TENANT_ID=t-enterprise RESOURCE_TYPE=api_requests [PRIORITY=medium] [AMOUNT=1]"; \
		echo "üìã Available resource types: api_requests, scan_jobs, storage_gb, compute_hours, bandwidth_mbps, concurrent_scans"; \
		exit 1; \
	fi
	@echo "üì• Submitting $(RESOURCE_TYPE) request for $(TENANT_ID)..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py submit-request $(TENANT_ID) $(RESOURCE_TYPE) $(or $(PRIORITY),medium) $(or $(AMOUNT),1)

g8-update-quota: ## Update tenant quota (requires TENANT_ID, RESOURCE_TYPE, NEW_LIMIT)
	@if [ -z "$(TENANT_ID)" ] || [ -z "$(RESOURCE_TYPE)" ] || [ -z "$(NEW_LIMIT)" ]; then \
		echo "‚ùå Usage: make g8-update-quota TENANT_ID=t-enterprise RESOURCE_TYPE=api_requests NEW_LIMIT=5000 [BURST_ALLOWANCE=1000]"; \
		exit 1; \
	fi
	@echo "üìù Updating quota for $(TENANT_ID): $(RESOURCE_TYPE) ‚Üí $(NEW_LIMIT)..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py update-quota $(TENANT_ID) $(RESOURCE_TYPE) $(NEW_LIMIT) $(BURST_ALLOWANCE)

g8-monitor-fairness: ## Monitor fairness metrics in real-time (Ctrl+C to stop)
	@echo "üëÅÔ∏è Starting real-time fairness monitoring..."
	@echo "Press Ctrl+C to stop monitoring"
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py monitor-fairness $(or $(DURATION),300)

g8-load-test: ## Run WFQ scheduler load test
	@echo "üß™ Running G8 WFQ scheduler load test..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py load-test $(or $(NUM_TENANTS),5) $(or $(REQUESTS_PER_TENANT),10)

g8-test-fairness: ## Test fairness under different load patterns
	@echo "üéØ Testing G8 fairness under various load patterns..."
	@echo "Phase 1: Balanced load..."
	@for tenant in enterprise professional starter; do \
		make g8-submit-request TENANT_ID=t-$$tenant RESOURCE_TYPE=api_requests AMOUNT=5 PRIORITY=medium 2>/dev/null & \
	done; wait
	@sleep 2
	@echo "Phase 2: Heavy enterprise load..."
	@make g8-submit-request TENANT_ID=t-enterprise RESOURCE_TYPE=api_requests AMOUNT=20 PRIORITY=high 2>/dev/null
	@sleep 2
	@echo "Phase 3: Checking fairness impact..."
	@source venv/bin/activate && python3 tools/scripts/g8_control_plane_cli.py system-status | grep -A 10 "Fairness"
	@echo "‚úÖ Fairness test completed"

g8-api-test: ## Test G8 Control Plane REST API endpoints
	@echo "üîå Testing G8 Control Plane REST API..."
	@if ! pgrep -f "uvicorn.*app.main:app" > /dev/null; then \
		echo "‚ùå API server not running. Start with: cd src/api && uvicorn app.main:app --reload"; \
		exit 1; \
	fi
	@echo "üìä Testing system status endpoint..."
	@curl -s http://localhost:8000/api/v1/control-plane/system/status | jq '.system_health.control_plane_running // "API not responding"' 2>/dev/null || echo "‚ùå API request failed"
	@echo "üè¢ Testing tenant creation..."
	@curl -s -X POST http://localhost:8000/api/v1/control-plane/tenants/create \
		-H "Content-Type: application/json" \
		-d '{"tenant_id":"api-test-tenant","tier":"professional"}' | jq '.message // "Creation failed"' 2>/dev/null || echo "‚ùå Tenant creation failed"
	@echo "‚úÖ API test completed"

g8-cleanup: ## Clean up control plane storage and test data
	@echo "üßπ Cleaning up G8 Control Plane data..."
	@rm -rf control_plane_storage/
	@rm -rf quota_storage/
	@echo "‚úÖ Control Plane data cleaned"

# =====================================
# Phase G4 Replay-Safe Streaming Targets
# =====================================

replay-plan: ## Plan replay infrastructure diff (show IaC changes)
	@echo "üîç Planning Phase G4 replay infrastructure changes..."
	@cd infra/iac/nats && terraform init -upgrade >/dev/null 2>&1
	@cd infra/iac/nats && terraform plan -var-file="environments/dev.tfvars" \
		-var 'replay_policy={time_window_hours=168,global_rate_limit_bps=5242880,max_replay_workers=5,storage_isolation=true,start_time_policy="ByStartTime"}' \
		2>/dev/null | grep -A 50 -B 5 "replay" || echo "No replay-specific changes found"
	@echo ""
	@echo "üéØ Key replay features being deployed:"
	@echo "  üìº Dedicated replay lanes with .replay suffix"
	@echo "  üïê Time-bounded windows (7 days default)"
	@echo "  üö¶ Rate limiting: 5MB/s global, 2MB/s per worker"
	@echo "  üë• Max 5 concurrent replay workers"
	@echo "  üîß Lower I/O priority (5 vs 1 for live)"
	@echo "  üéØ DeliverPolicy=ByStartTime for bounded replay"

replay-drill: ## Execute chaos drill with 10x replay load
	@echo "üß™ Starting Phase G4 replay-safe streaming chaos drill..."
	@echo "üìä SLO Targets:"
	@echo "  ‚Ä¢ Live P95 < 100ms"
	@echo "  ‚Ä¢ Replay success rate > 95%"
	@echo "  ‚Ä¢ Duration: 5 minutes"
	@echo "  ‚Ä¢ Load: 10x replay multiplier"
	@echo ""
	@if [ ! -f "tools/replay/drill.sh" ]; then \
		echo "‚ùå Drill script not found. Ensure tools/replay/drill.sh exists."; \
		exit 1; \
	fi
	@chmod +x tools/replay/drill.sh
	@TENANT_ID=t-qa \
		NATS_URL=${NATS_URL:-nats://localhost:4222} \
		PROMETHEUS_URL=${PROMETHEUS_URL:-http://localhost:9090} \
		GRAFANA_URL=${GRAFANA_URL:-http://localhost:3000} \
		LIVE_P95_TARGET_MS=100 \
		REPLAY_SUCCESS_RATE_TARGET=0.95 \
		DRILL_DURATION_SECONDS=300 \
		REPLAY_MULTIPLIER=10 \
		./tools/replay/drill.sh

replay-validate: ## Validate SLO compliance from recent drill results
	@echo "üîç Validating Phase G4 SLO compliance from latest drill..."
	@if [ ! -f "tools/replay/output/analysis.json" ]; then \
		echo "‚ùå No drill results found. Run 'make replay-drill' first."; \
		exit 1; \
	fi
	@echo "üìä Latest Drill Results:"
	@python3 -c "import json; \
		data = json.load(open('tools/replay/output/analysis.json')); \
		print(f'  Live P95: {data[\"drill_summary\"][\"live_p95_latency_ms\"]:.2f}ms (target: 100ms)'); \
		print(f'  Replay Success: {data[\"drill_summary\"][\"replay_success_rate\"]:.3f} (target: 0.95)'); \
		compliant = data['slo_compliance']['live_p95_compliant'] and data['slo_compliance']['replay_success_compliant']; \
		print(f'  SLO Compliance: PASS' if compliant else '  SLO Compliance: FAIL'); \
		exit(0 if compliant else 1)"

replay-infrastructure: ## Deploy replay-safe streaming infrastructure
	@echo "üöÄ Deploying Phase G4 replay-safe streaming infrastructure..."
	@make nats-iac-plan
	@echo ""
	@echo "üìã Infrastructure includes:"
	@echo "  üìº Dedicated replay streams with .replay suffix"
	@echo "  üë• Bounded replay consumers (max 5 workers)"
	@echo "  üéöÔ∏è Rate limiting and priority controls"
	@echo "  üìä SLO monitoring and alerting"
	@echo ""
	@echo "Deploy with: make nats-iac-apply"

replay-dashboard: ## Launch Grafana replay dashboard
	@echo "üìä Opening XORB Replay-Safe Streaming Dashboard..."
	@GRAFANA_URL=${GRAFANA_URL:-http://localhost:3000}
	@echo "üîó Dashboard URL: $$GRAFANA_URL/d/xorb-replay/xorb-replay-safe-streaming"
	@echo ""
	@echo "Key panels to monitor:"
	@echo "  üéØ SLO Overview: Live P95 < 100ms, Replay Success > 95%"
	@echo "  üìà Live vs Replay message rates and lag"
	@echo "  üö¶ Flow control hits and backpressure"
	@echo "  üìä Rate limiting and worker utilization"
	@echo "  ‚ö†Ô∏è Redeliveries and error rates"
	@echo ""
	@if command -v xdg-open >/dev/null 2>&1; then \
		xdg-open "$$GRAFANA_URL/d/xorb-replay/xorb-replay-safe-streaming"; \
	elif command -v open >/dev/null 2>&1; then \
		open "$$GRAFANA_URL/d/xorb-replay/xorb-replay-safe-streaming"; \
	else \
		echo "Open the URL above manually in your browser"; \
	fi

replay-runbook: ## Display incident response runbook
	@echo "üìñ XORB Phase G4 Replay-Safe Streaming Runbook"
	@echo "==============================================="
	@echo ""
	@echo "üö® LIVE P95 LATENCY VIOLATION (> 100ms)"
	@echo "Symptoms: Live streams experiencing high publish‚Üídeliver latency"
	@echo "Actions:"
	@echo "  1. Check replay worker count: sum(nats_jetstream_consumer_active{stream_class=\"replay\"})"
	@echo "  2. Scale down replay workers if > 5 active"
	@echo "  3. Check live consumer flow control hits"
	@echo "  4. Verify live stream priority settings (should be 1)"
	@echo "  5. Consider temporarily pausing replay operations"
	@echo ""
	@echo "üö® REPLAY SUCCESS RATE VIOLATION (< 95%)"
	@echo "Symptoms: Replay operations failing at high rate"
	@echo "Actions:"
	@echo "  1. Check replay rate limiting: sum(rate(nats_jetstream_consumer_bytes{stream_class=\"replay\"}[5m]))"
	@echo "  2. Verify bounded window settings (7 days default)"
	@echo "  3. Check replay consumer redelivery rates"
	@echo "  4. Validate replay stream storage quotas (2GB limit)"
	@echo "  5. Review ByStartTime deliver policy configuration"
	@echo ""
	@echo "üö¶ FLOW CONTROL BACKPRESSURE"
	@echo "Symptoms: Consumers hitting flow control limits"
	@echo "Actions:"
	@echo "  1. Monitor: rate(nats_jetstream_consumer_flow_control[5m])"
	@echo "  2. Check max_ack_pending limits (1024 live, 256 replay)"
	@echo "  3. Verify idle_heartbeat settings (5s live, 10s replay)"
	@echo "  4. Scale consumer processing capacity"
	@echo ""
	@echo "üìä MONITORING QUERIES"
	@echo "Live P95: histogram_quantile(0.95, sum(rate(nats_request_duration_seconds_bucket{stream_class=\"live\"}[5m])) by (le)) * 1000"
	@echo "Replay Success: sum(rate(nats_jetstream_consumer_delivered{stream_class=\"replay\"}[5m])) / sum(rate(nats_jetstream_stream_messages{stream_class=\"replay\"}[5m]))"
	@echo "Consumer Lag: nats_jetstream_stream_messages - nats_jetstream_consumer_delivered"
	@echo ""
	@echo "üîó Dashboard: $${GRAFANA_URL:-http://localhost:3000}/d/xorb-replay/xorb-replay-safe-streaming"
	@echo "üìû Escalation: Check prometheus alerts for active incidents"

# ==========================================
# Phase G5 Observability & SLO Targets
# ==========================================

obs-instrument: ## Initialize G5 observability instrumentation
	@echo "üìä Setting up Phase G5 Observability & SLO instrumentation..."
	@echo "üîß Initializing OpenTelemetry + Prometheus integration..."
	@cd src/api && python3 -c " \
		from app.observability import setup_instrumentation, get_sli_metrics; \
		setup_instrumentation(app_name='xorb-api', version='3.0.0', environment='production', prometheus_port=8080, enable_otlp=True); \
		sli = get_sli_metrics(); \
		print(f'‚úÖ {len(sli.get_sli_targets())} SLI targets configured'); \
		print('üìä Core SLIs:'); \
		for target in sli.get_sli_targets(): \
			print(f'  ‚Ä¢ {target.name}: P{int(target.target_percentile*100)} < {target.target_value_ms}ms (SLO: {100-target.error_budget_percent:.1f}%)'); \
	" || { echo "‚ùå Failed to initialize instrumentation"; exit 1; }
	@echo "üåê Prometheus metrics endpoint: http://localhost:8080/metrics"
	@echo "‚úÖ G5 Observability instrumentation initialized successfully"

obs-dashboards: ## Provision Grafana SLO dashboards
	@echo "üìä Provisioning Phase G5 SLO dashboards..."
	@GRAFANA_URL=${GRAFANA_URL:-http://localhost:3000}
	@GRAFANA_API_KEY=${GRAFANA_API_KEY:-admin}
	@if ! curl -s -o /dev/null -w "%{http_code}" "$$GRAFANA_URL/api/health" | grep -q "200"; then \
		echo "‚ùå Grafana not accessible at $$GRAFANA_URL. Start Grafana first."; \
		exit 1; \
	fi
	@echo "üì§ Uploading SLO Error Budget Dashboard..."
	@curl -s -X POST \
		-H "Authorization: Bearer $$GRAFANA_API_KEY" \
		-H "Content-Type: application/json" \
		-d @infra/monitoring/grafana/dashboards/xorb-slo-error-budgets.json \
		"$$GRAFANA_URL/api/dashboards/db" > /tmp/grafana_response.json || { \
		echo "‚ùå Failed to upload dashboard"; \
		cat /tmp/grafana_response.json; \
		exit 1; \
	}
	@if grep -q '"status":"success"' /tmp/grafana_response.json; then \
		echo "‚úÖ SLO Error Budget Dashboard provisioned successfully"; \
	else \
		echo "‚ö†Ô∏è Dashboard upload completed with warnings:"; \
		cat /tmp/grafana_response.json; \
	fi
	@echo "üîó Dashboard URL: $$GRAFANA_URL/d/xorb-slo-error-budgets/xorb-phase-g5-slo-error-budget-dashboard"
	@echo "üìä Dashboard includes:"
	@echo "  ‚Ä¢ Bus publish-to-deliver P95 latency SLI"
	@echo "  ‚Ä¢ Evidence ingest P95 latency SLI"
	@echo "  ‚Ä¢ Authentication error rate SLI"
	@echo "  ‚Ä¢ mTLS handshake failure rate SLI"
	@echo "  ‚Ä¢ Replay backlog depth monitoring"
	@echo "  ‚Ä¢ Error budget remaining gauges"
	@echo "  ‚Ä¢ Multi-window burn rate tracking"

obs-validate: ## Validate SLO configuration
	@echo "üîç Validating Phase G5 SLO configuration..."
	@echo "üìã Checking Prometheus alert rules..."
	@if command -v promtool >/dev/null 2>&1; then \
		promtool check rules infra/monitoring/xorb-slo-alert-rules.yml; \
	else \
		echo "‚ö†Ô∏è promtool not found. Install Prometheus to validate rules."; \
	fi
	@echo ""
	@echo "üéØ Validating SLI metric targets..."
	@cd src/api && python3 -c " \
		from app.observability.sli_metrics import get_sli_metrics; \
		from app.observability.error_budgets import get_error_budget_tracker; \
		sli = get_sli_metrics(); \
		tracker = get_error_budget_tracker(); \
		targets = sli.get_sli_targets(); \
		print(f'‚úÖ {len(targets)} SLI targets validated:'); \
		for i, target in enumerate(targets, 1): \
			print(f'  {i}. {target.name}'); \
			print(f'     Target: P{int(target.target_percentile*100)} < {target.target_value_ms}ms'); \
			print(f'     SLO: {100-target.error_budget_percent:.1f}% (error budget: {target.error_budget_percent}%)'); \
			print(f'     Window: {target.measurement_window_hours}h'); \
			print(''); \
		print('üî• Error budget burn rate thresholds:'); \
		print('  ‚Ä¢ Fast burn: 14.4x (2% budget in 1h) ‚Üí Critical alert'); \
		print('  ‚Ä¢ Medium burn: 6.0x (5% budget in 6h) ‚Üí Warning alert'); \
		print('  ‚Ä¢ Slow burn: 1.0x (10% budget in 3d) ‚Üí Ticket'); \
	" || { echo "‚ùå SLI validation failed"; exit 1; }
	@echo "‚úÖ All SLO configurations validated successfully"

obs-report: ## Generate SLO compliance report
	@echo "üìã Generating Phase G5 SLO compliance report..."
	@cd src/api && python3 -c " \
		from app.observability.error_budgets import generate_slo_report; \
		from app.observability.sli_metrics import get_sli_metrics; \
		import json; \
		from datetime import datetime; \
		print('üéØ XORB Phase G5 SLO Compliance Report'); \
		print('=' * 45); \
		print(f'Generated: {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S UTC\")}'); \
		print(''); \
		sli = get_sli_metrics(); \
		targets = sli.get_sli_targets(); \
		print(f'üìä Configured SLIs: {len(targets)}'); \
		print(''); \
		for target in targets: \
			print(f'‚Ä¢ {target.name.replace(\"_\", \" \").title()}'); \
			print(f'  Target: P{int(target.target_percentile*100)} < {target.target_value_ms}ms'); \
			print(f'  SLO: {100-target.error_budget_percent:.1f}%'); \
			print(''); \
		report = generate_slo_report(); \
		print('üè• Current Platform Health:'); \
		print(f'  Overall Status: {report[\"overall_status\"].upper()}'); \
		print(f'  Total SLIs: {report[\"summary\"][\"total_slis\"]}'); \
		print(f'  Healthy: {report[\"summary\"][\"healthy\"]}'); \
		print(f'  Warning: {report[\"summary\"][\"warning\"]}'); \
		print(f'  Critical: {report[\"summary\"][\"critical\"]}'); \
		print(''); \
		print('üìà Next Steps:'); \
		if report[\"overall_status\"] == \"healthy\": \
			print('  ‚Ä¢ Continue monitoring SLI performance'); \
			print('  ‚Ä¢ Review error budget utilization weekly'); \
			print('  ‚Ä¢ Plan capacity based on traffic growth'); \
		else: \
			print('  ‚Ä¢ Investigate SLIs in warning/critical state'); \
			print('  ‚Ä¢ Review error budget burn rates'); \
			print('  ‚Ä¢ Consider service capacity scaling'); \
		print(''); \
		print('üîó Dashboards:'); \
		print('  ‚Ä¢ SLO Overview: http://localhost:3000/d/xorb-slo-error-budgets'); \
		print('  ‚Ä¢ Platform Status: http://localhost:8000/api/v1/enhanced-health'); \
		print('');\
	" || { echo "‚ùå Failed to generate SLO report"; exit 1; }

obs-test-alerts: ## Test error budget alert rules
	@echo "üö® Testing Phase G5 error budget alert rules..."
	@ALERTMANAGER_URL=${ALERTMANAGER_URL:-http://localhost:9093}
	@if ! curl -s -o /dev/null -w "%{http_code}" "$$ALERTMANAGER_URL/api/v1/status" | grep -q "200"; then \
		echo "‚ùå Alertmanager not accessible at $$ALERTMANAGER_URL"; \
		echo "Start Alertmanager or set ALERTMANAGER_URL environment variable"; \
		exit 1; \
	fi
	@echo "üì§ Sending test alerts to Alertmanager..."
	@echo "üî• Testing fast burn rate alert (critical)..."
	@curl -s -X POST "$$ALERTMANAGER_URL/api/v1/alerts" \
		-H "Content-Type: application/json" \
		-d '[{ \
			"labels": { \
				"alertname": "XORBSLOBusLatencyFastBurn", \
				"severity": "critical", \
				"service": "xorb-backplane", \
				"sli": "bus_publish_to_deliver_p95_ms", \
				"tenant_id": "test-tenant", \
				"alert_type": "fast_burn" \
			}, \
			"annotations": { \
				"summary": "Test alert: XORB Bus Latency SLO fast burn rate detected", \
				"description": "Test alert from make obs-test-alerts command" \
			}, \
			"startsAt": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'", \
			"endsAt": "'$(date -u -d '+5 minutes' +%Y-%m-%dT%H:%M:%SZ)'" \
		}]' > /dev/null
	@echo "‚ö†Ô∏è Testing medium burn rate alert (warning)..."
	@curl -s -X POST "$$ALERTMANAGER_URL/api/v1/alerts" \
		-H "Content-Type: application/json" \
		-d '[{ \
			"labels": { \
				"alertname": "XORBSLOEvidenceIngestMediumBurn", \
				"severity": "warning", \
				"service": "xorb-evidence", \
				"sli": "evidence_ingest_p95_ms", \
				"tenant_id": "test-tenant", \
				"alert_type": "medium_burn" \
			}, \
			"annotations": { \
				"summary": "Test alert: XORB Evidence Ingest SLO medium burn rate detected", \
				"description": "Test alert from make obs-test-alerts command" \
			}, \
			"startsAt": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'", \
			"endsAt": "'$(date -u -d '+5 minutes' +%Y-%m-%dT%H:%M:%SZ)'" \
		}]' > /dev/null
	@echo "‚úÖ Test alerts sent successfully"
	@echo ""
	@echo "üîç Check alert status:"
	@echo "  ‚Ä¢ Alertmanager UI: $$ALERTMANAGER_URL"
	@echo "  ‚Ä¢ Active alerts: curl $$ALERTMANAGER_URL/api/v1/alerts | jq '.data[] | select(.labels.alertname | startswith(\"XORBSLO\"))'"
	@echo ""
	@echo "üìû Verify alert routing:"
	@echo "  ‚Ä¢ Check configured receivers (Slack/PagerDuty/email)"
	@echo "  ‚Ä¢ Verify alert grouping and deduplication"
	@echo "  ‚Ä¢ Test escalation policies and on-call rotation"

# ==========================================
# Phase G6 Tenant-Isolated Backplane Targets
# ==========================================

g6-tenant-plan: ## Plan G6 tenant isolation infrastructure with enhanced quotas
	@echo "üìã Planning Phase G6 tenant-isolated backplane infrastructure..."
	@echo "üîß Features:"
	@echo "  ‚Ä¢ Per-tenant NATS accounts with strict isolation"
	@echo "  ‚Ä¢ Rate limiting quotas (10MB/s - 100MB/s by tier)"
	@echo "  ‚Ä¢ Connection limits (50 - 1000 by tier)"
	@echo "  ‚Ä¢ Subject-level access control with deny patterns"
	@echo "  ‚Ä¢ Enhanced burst allowance for enterprise tiers"
	@echo "  ‚Ä¢ Integration with G5 observability metrics"
	@echo ""
	@cd infra/iac/nats && terraform init -upgrade >/dev/null 2>&1
	@cd infra/iac/nats && terraform plan -var-file="environments/dev.tfvars" -out=g6-tfplan 2>/dev/null || { \
		echo "Using G6 enhanced tenant configurations..."; \
		terraform plan -out=g6-tfplan; \
	}
	@echo ""
	@echo "üéØ G6 Tenant Tiers:"
	@echo "  üè¢ Enterprise: 500 streams, 1000 consumers, 10GB storage, 100MB/s rate limit"
	@echo "  üíº Professional: 100 streams, 200 consumers, 2GB storage, 50MB/s rate limit"  
	@echo "  üöÄ Starter: 25 streams, 50 consumers, 512MB storage, 10MB/s rate limit"
	@echo ""
	@echo "‚úÖ Terraform plan completed. Review g6-tfplan file."

g6-tenant-apply: ## Apply G6 tenant accounts with enhanced quotas and isolation
	@echo "üöÄ Applying Phase G6 tenant-isolated backplane infrastructure..."
	@echo "‚ö†Ô∏è  This will create/update NATS accounts with strict tenant isolation"
	@if [ ! -f "infra/iac/nats/g6-tfplan" ]; then \
		echo "‚ùå No G6 terraform plan found. Run 'make g6-tenant-plan' first."; \
		exit 1; \
	fi
	@cd infra/iac/nats && terraform apply g6-tfplan
	@echo ""
	@echo "‚úÖ G6 tenant isolation infrastructure deployed successfully"
	@echo "üìÑ Tenant configurations generated in infra/iac/nats/out/"
	@echo "üîê JWT credentials created per tenant:"
	@ls -la infra/iac/nats/out/tenant-*-user.jwt 2>/dev/null | sed 's/.*tenant-\(.*\)-user.jwt/  ‚Ä¢ \1/' || echo "  (credentials pending)"
	@echo ""
	@echo "üß™ Next steps:"
	@echo "  1. Run 'make g6-tenant-validate' to test isolation"
	@echo "  2. Check tenant configurations in infra/iac/nats/out/"
	@echo "  3. Integrate tenant configs with application services"

g6-tenant-test: ## Run G6 tenant isolation unit tests (pytest)
	@echo "üß™ Running Phase G6 tenant isolation tests..."
	@echo "üìã Test scope:"
	@echo "  ‚Ä¢ Cross-tenant publish/subscribe denial"
	@echo "  ‚Ä¢ Admin subject access prevention"  
	@echo "  ‚Ä¢ Request/reply isolation"
	@echo "  ‚Ä¢ Rate limiting by tenant tier"
	@echo "  ‚Ä¢ Configuration completeness validation"
	@echo ""
	@cd tests/unit/backplane && python3 -m pytest test_g6_tenant_isolation.py -v \
		--tb=short \
		-k "test_g6" || { \
		echo "‚ùå Tenant isolation tests failed"; \
		echo "Check test output for specific failures"; \
		exit 1; \
	}
	@echo ""
	@echo "‚úÖ G6 tenant isolation unit tests passed"
	@echo "üìä Tests verified tenant isolation mechanisms work correctly"

g6-tenant-validate: ## Validate G6 tenant isolation against live NATS (real test)
	@echo "üîç Validating Phase G6 tenant isolation against live infrastructure..."
	@NATS_URL=${NATS_URL:-nats://localhost:4222}
	@if ! nc -z localhost 4222 2>/dev/null; then \
		echo "‚ùå NATS server not accessible at $$NATS_URL"; \
		echo "Start NATS server with: nats-server -js -p 4222"; \
		exit 1; \
	fi
	@if [ ! -d "infra/iac/nats/out" ]; then \
		echo "‚ùå No tenant configurations found."; \
		echo "Run 'make g6-tenant-apply' to create tenant infrastructure first."; \
		exit 1; \
	fi
	@echo "üì° Running live tenant isolation validation..."
	@python3 tools/scripts/g6_tenant_isolation_validator.py \
		--nats-url="$$NATS_URL" \
		--config-dir="infra/iac/nats/out" \
		--output="g6_isolation_validation_report.json" || { \
		echo "‚ùå Tenant isolation validation failed!"; \
		echo "Check g6_isolation_validation_report.json for details"; \
		exit 1; \
	}
	@echo ""
	@echo "‚úÖ G6 tenant isolation validation passed!"
	@echo "üìä Report saved to: g6_isolation_validation_report.json"
	@echo ""
	@echo "üîê Validation confirmed:"
	@echo "  ‚Ä¢ Tenant A cannot access Tenant B's subjects"
	@echo "  ‚Ä¢ Admin subject access properly denied"
	@echo "  ‚Ä¢ Rate limiting enforced per tenant tier"
	@echo "  ‚Ä¢ Request/reply patterns isolated"
	@echo "  ‚Ä¢ Subject wildcard bypasses prevented"

# ==========================================
# Phase G7 Provable Evidence v1 Targets
# ==========================================

g7-evidence-setup: ## Setup G7 cryptographic evidence infrastructure
	@echo "üîê Setting up Phase G7 provable evidence infrastructure..."
	@echo "üîß Features:"
	@echo "  ‚Ä¢ Ed25519 cryptographic signatures for tamper-proof evidence"
	@echo "  ‚Ä¢ RFC 3161 trusted timestamps for legal compliance"
	@echo "  ‚Ä¢ Chain of custody tracking for forensic requirements"
	@echo "  ‚Ä¢ IPFS integration for immutable storage"
	@echo "  ‚Ä¢ Merkle tree roll-ups for efficient verification"
	@echo ""
	@echo "üìÅ Creating evidence storage directories..."
	@mkdir -p evidence_storage evidence_keys rollup_storage
	@echo "‚úÖ Evidence storage directories created"
	@echo ""
	@echo "üì¶ Installing cryptographic dependencies..."
	@pip install cryptography requests ipfshttpclient 2>/dev/null || { \
		echo "‚ö†Ô∏è Some dependencies may not be available - continuing with available features"; \
	}
	@echo ""
	@echo "üîë Testing Ed25519 key generation..."
	@cd src/api && python3 -c " \
		from app.services.g7_provable_evidence_service import Ed25519KeyManager; \
		km = Ed25519KeyManager(); \
		private_key, public_key = km.generate_tenant_key('test-tenant'); \
		print('‚úÖ Ed25519 key generation successful'); \
	" || { \
		echo "‚ùå Ed25519 key generation failed"; \
		exit 1; \
	}
	@echo ""
	@echo "‚úÖ G7 provable evidence infrastructure setup complete"
	@echo "üîó API endpoints available at: http://localhost:8000/api/v1/provable-evidence/"

g7-evidence-test: ## Test G7 evidence creation and verification
	@echo "üß™ Testing Phase G7 provable evidence system..."
	@echo "üìã Test scope:"
	@echo "  ‚Ä¢ Evidence creation with Ed25519 signatures"
	@echo "  ‚Ä¢ Trusted timestamp generation"
	@echo "  ‚Ä¢ Chain of custody tracking"
	@echo "  ‚Ä¢ Cryptographic verification"
	@echo "  ‚Ä¢ Storage and retrieval"
	@echo ""
	@cd src/api && python3 -c " \
		import asyncio; \
		from app.services.g7_provable_evidence_service import ( \
			ProvableEvidenceService, EvidenceType, EvidenceFormat \
		); \
		async def test_evidence(): \
			service = ProvableEvidenceService(); \
			print('üîê Creating test evidence...'); \
			evidence = await service.create_evidence( \
				tenant_id='test-tenant', \
				evidence_type=EvidenceType.SCAN_RESULT, \
				format=EvidenceFormat.JSON, \
				content=b'{\"scan\": \"nmap results\", \"targets\": [\"127.0.0.1\"]}', \
				title='Test Security Scan', \
				description='Automated test of evidence creation', \
				source_system='test-system', \
				source_user='test-user', \
				tags=['test', 'security', 'scan'] \
			); \
			print(f'‚úÖ Evidence created: {evidence.metadata.evidence_id}'); \
			print('üîç Verifying evidence integrity...'); \
			verification = await service.verify_evidence(evidence); \
			if verification['overall_valid']: \
				print('‚úÖ Evidence verification passed'); \
				print(f'   ‚Ä¢ Content hash: valid'); \
				print(f'   ‚Ä¢ Signature: valid'); \
				print(f'   ‚Ä¢ Timestamp: {verification[\"checks\"].get(\"trusted_timestamp\", {}).get(\"valid\", \"unavailable\")}'); \
				print(f'   ‚Ä¢ Chain of custody: {len(evidence.chain_of_custody)} entries'); \
			else: \
				print('‚ùå Evidence verification failed'); \
				for check, result in verification['checks'].items(): \
					if not result.get('valid', True): \
						print(f'   ‚Ä¢ {check}: FAILED - {result.get(\"error\", \"unknown\")}'); \
		asyncio.run(test_evidence()); \
	" || { \
		echo "‚ùå Evidence testing failed"; \
		exit 1; \
	}
	@echo ""
	@echo "‚úÖ G7 evidence creation and verification tests passed"

g7-merkle-rollup: ## Create G7 weekly Merkle tree roll-up
	@echo "üå≥ Creating Phase G7 weekly Merkle tree roll-up..."
	@echo "üìÖ Processing evidence from previous week..."
	@WEEKS_BACK=${WEEKS_BACK:-0}
	@python3 tools/scripts/g7_merkle_rollup_job.py \
		--weeks-back=$$WEEKS_BACK \
		--evidence-storage=evidence_storage \
		--rollup-storage=rollup_storage || { \
		echo "‚ùå Merkle roll-up creation failed"; \
		exit 1; \
	}
	@echo ""
	@echo "üìä Available rollups:"
	@python3 tools/scripts/g7_merkle_rollup_job.py --list-rollups
	@echo ""
	@echo "‚úÖ Weekly Merkle roll-up completed successfully"
	@echo "üîç Use 'make g7-verify-rollup ROLLUP_ID=<id> EVIDENCE_ID=<id>' to verify specific evidence"

g7-verify-rollup: ## Verify G7 evidence inclusion in Merkle roll-up
	@echo "üîç Verifying evidence inclusion in Merkle roll-up..."
	@if [ -z "$(ROLLUP_ID)" ] || [ -z "$(EVIDENCE_ID)" ]; then \
		echo "‚ùå Usage: make g7-verify-rollup ROLLUP_ID=<rollup_id> EVIDENCE_ID=<evidence_id>"; \
		echo ""; \
		echo "üìã Available rollups:"; \
		python3 tools/scripts/g7_merkle_rollup_job.py --list-rollups; \
		exit 1; \
	fi
	@echo "üÜî Rollup ID: $(ROLLUP_ID)"
	@echo "üÜî Evidence ID: $(EVIDENCE_ID)"
	@echo ""
	@python3 tools/scripts/g7_merkle_rollup_job.py \
		--verify="$(ROLLUP_ID):$(EVIDENCE_ID)" || { \
		echo "‚ùå Evidence verification in rollup failed"; \
		exit 1; \
	}
	@echo ""
	@echo "‚úÖ Evidence Merkle proof verification completed"

# ==========================================
# API & Schema Compatibility Gate Targets
# ==========================================

contract-check: ## Run both protobuf and OpenAPI compatibility checks
	@echo "üîç Running API & Schema Compatibility Checks..."
	@echo ""
	@echo "üìã Protobuf Compatibility Check:"
	python3 tools/contracts/check_proto_compat.py
	@echo ""
	@echo "üìã OpenAPI Compatibility Check:"
	python3 tools/contracts/check_openapi_compat.py
	@echo ""
	@echo "‚úÖ All compatibility checks completed"

contract-report: ## Open/print the latest compatibility reports
	@echo "üìñ Opening latest compatibility reports..."
	@echo ""
	@echo "üîê Protobuf Compatibility Report:"
	@echo "=================================="
	@cat tools/contracts/reports/proto_compat.md || echo "No protobuf report found"
	@echo ""
	@echo "üåê OpenAPI Compatibility Report:"
	@echo "================================"
	@cat tools/contracts/reports/openapi_compat.md || echo "No OpenAPI report found"

install-contract-deps: ## Install contract checking dependencies (buf, protoc, etc.)
	@echo "üì¶ Installing contract checking dependencies..."
	@echo ""
	@echo "üîç Checking for buf (protobuf linter/breaking change detector)..."
	@if command -v buf >/dev/null 2>&1; then 
		echo "‚úÖ buf already installed"; 
	else 
		echo "üì• Installing buf..."; 
		curl -sSL 
			"https://github.com/bufbuild/buf/releases/download/v1.27.0/buf-$(shell uname -s)-$(shell uname -m)" 
			-o "$(mktemp)" && 
			chmod +x "$(mktemp)" && 
			sudo mv "$(mktemp)" /usr/local/bin/buf && 
			echo "‚úÖ buf installed successfully"; 
	fi
	@echo ""
	@echo "üîç Checking for protoc (protobuf compiler)..."
	@if command -v protoc >/dev/null 2>&1; then 
		echo "‚úÖ protoc already installed"; 
	else 
		echo "üì• Installing protoc..."; 
		PROTOC_VERSION=21.12 && 
		PROTOC_ZIP="protoc-${PROTOC_VERSION}-linux-x86_64.zip" && 
		curl -sSL "https://github.com/protocolbuffers/protobuf/releases/download/v${PROTOC_VERSION}/${PROTOC_ZIP}" 
			-o "$(mktemp)" && 
			unzip -o "$(mktemp)" -d "$(mktemp -d)" && 
			sudo cp -r "$(mktemp -d)/bin/." /usr/local/bin/ && 
			sudo cp -r "$(mktemp -d)/include/." /usr/local/include/ && 
			rm -rf "$(mktemp -d)" "$(mktemp)" && 
			echo "‚úÖ protoc installed successfully"; 
	fi
	@echo ""
	@echo "üîç Checking for pyyaml..."
	@if python3 -c "import yaml" >/dev/null 2>&1; then 
		echo "‚úÖ pyyaml already installed"; 
	else 
		echo "üì• Installing pyyaml..."; 
		pip install pyyaml && 
			echo "‚úÖ pyyaml installed successfully"; 
	fi
	@echo ""
	@echo "‚úÖ All contract checking dependencies installed"
