from typing import Dict, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
from abc import ABC, abstractmethod
import asyncio
import aiohttp
from src/orchestrator.core.workflow_engine import TaskExecutor, WorkflowTask, WorkflowExecution
from src/orchestrator.core.base_classes import ServiceConfig

@dataclass
class VulnerabilityScanConfig:
    """Configuration for vulnerability scan executor"""
    scanner_service_url: str
    timeout_minutes: int = 60
    retry_count: int = 2
    retry_delay_seconds: int = 300
    max_concurrent_scans: int = 10
    scan_poll_interval: int = 60

class VulnerabilityScanExecutor(TaskExecutor):
    """Executor for vulnerability scanning tasks"""
    
    def __init__(self, config: VulnerabilityScanConfig):
        self.config = config
        self._semaphore = asyncio.Semaphore(config.max_concurrent_scans)
        
    async def execute(self, task: WorkflowTask, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute vulnerability scan task"""
        try:
            # Validate parameters
            if not self.validate_parameters(task.parameters):
                raise ValueError("Invalid task parameters")
                
            # Acquire semaphore to limit concurrent scans
            async with self._semaphore:
                return await self._execute_scan(task, context)
                
        except Exception as e:
            logger.error(f"Vulnerability scan failed: {e}")
            raise
            
    async def _execute_scan(self, task: WorkflowTask, context: Dict[str, Any]) -> Dict[str, Any]:
        """Internal method to execute scan with semaphore acquired"""
        params = task.parameters
        target = params.get('target')
        scan_type = params.get('scan_type', 'comprehensive')
        
        async with aiohttp.ClientSession() as session:
            payload = {
                'target': target,
                'scan_type': scan_type,
                'options': params.get('options', {}),
                'workflow_execution_id': context['execution_id']
            }
            
            async with session.post(f"{self.config.scanner_service_url}/api/v1/scans", 
                                  json=payload) as response:
                if response.status == 200:
                    scan_data = await response.json()
                    scan_id = scan_data['scan_id']
                    
                    # Poll for completion
                    return await self._wait_for_scan_completion(session, scan_id)
                else:
                    raise Exception(f"Failed to start scan: {response.status}")
                    
    async def _wait_for_scan_completion(self, session: aiohttp.ClientSession, scan_id: str) -> Dict[str, Any]:
        """Wait for scan completion with timeout"""
        max_attempts = self.config.timeout_minutes * 60 // self.config.scan_poll_interval
        attempt = 0
        
        while attempt < max_attempts:
            try:
                async with session.get(f"{self.config.scanner_service_url}/api/v1/scans/{scan_id}/status") as response:
                    if response.status == 200:
                        status_data = await response.json()
                        
                        if status_data['status'] == 'completed':
                            # Get full results
                            async with session.get(f"{self.config.scanner_service_url}/api/v1/scans/{scan_id}/results") as results_response:
                                if results_response.status == 200:
                                    results = await results_response.json()
                                    return {
                                        'scan_id': scan_id,
                                        'status': 'completed',
                                        'results': results,
                                        'vulnerabilities_found': len(results.get('vulnerabilities', [])),
                                        'severity_breakdown': results.get('severity_breakdown', {}),
                                        'scan_duration': results.get('duration_seconds', 0)
                                    }
                                    
                        elif status_data['status'] == 'failed':
                            raise Exception(f"Scan failed: {status_data.get('error', 'Unknown error')}")
                            
            except Exception as e:
                logger.warning(f"Error checking scan status: {e}")
                
            await asyncio.sleep(self.config.scan_poll_interval)  # Check at configured interval
            attempt += 1
            
        raise Exception(f"Scan timeout after {self.config.timeout_minutes} minutes")
        
    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        """Validate scan parameters"""
        required_fields = ['target']
        return all(field in parameters for field in required_fields)
        
    async def health_check(self) -> bool:
        """Check if scanner service is available"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.config.scanner_service_url}/api/v1/health") as response:
                    return response.status == 200
        except Exception:
            return False
        
    def get_capabilities(self) -> Dict[str, Any]:
        """Get executor capabilities"""
        return {
            'supported_scan_types': ['basic', 'comprehensive', 'api', 'network'],
            'max_concurrent_scans': self.config.max_concurrent_scans,
            'timeout_range': {
                'min': 5,
                'max': 240
            }
        }