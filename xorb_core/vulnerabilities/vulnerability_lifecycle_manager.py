"""
Automated Vulnerability Lifecycle Management

This module provides comprehensive vulnerability lifecycle management including
discovery, classification, prioritization, remediation tracking, and automated
workflow orchestration for the XORB ecosystem.
"""

import asyncio
import json
import time
import uuid
from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Union, Callable
from pathlib import Path

import structlog
from prometheus_client import Counter, Gauge, Histogram, Enum as PrometheusEnum

# Metrics
VULNERABILITY_DISCOVERED = Counter('xorb_vulnerabilities_discovered_total', 'Vulnerabilities discovered', ['severity', 'category'])
VULNERABILITY_STATE_CHANGES = Counter('xorb_vulnerability_state_changes_total', 'Vulnerability state changes', ['from_state', 'to_state'])
ACTIVE_VULNERABILITIES = Gauge('xorb_active_vulnerabilities', 'Active vulnerabilities', ['severity', 'category'])
REMEDIATION_TIME = Histogram('xorb_vulnerability_remediation_duration_seconds', 'Time to remediate vulnerabilities')
SLA_VIOLATIONS = Counter('xorb_vulnerability_sla_violations_total', 'SLA violations', ['severity'])

logger = structlog.get_logger(__name__)


class VulnerabilityState(Enum):
    """Vulnerability lifecycle states."""
    DISCOVERED = "discovered"
    TRIAGED = "triaged"
    CONFIRMED = "confirmed"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    TESTING = "testing"
    RESOLVED = "resolved"
    VERIFIED = "verified"
    CLOSED = "closed"
    FALSE_POSITIVE = "false_positive"
    RISK_ACCEPTED = "risk_accepted"
    DEFERRED = "deferred"


class VulnerabilitySeverity(Enum):
    """CVSS-based severity levels."""
    NONE = "none"          # 0.0
    LOW = "low"            # 0.1-3.9
    MEDIUM = "medium"      # 4.0-6.9
    HIGH = "high"          # 7.0-8.9
    CRITICAL = "critical"  # 9.0-10.0


class VulnerabilityCategory(Enum):
    """Vulnerability categories based on CWE."""
    INJECTION = "injection"                    # CWE-89, CWE-78, etc.
    AUTHENTICATION = "authentication"         # CWE-287, CWE-306
    ACCESS_CONTROL = "access_control"         # CWE-22, CWE-862
    CRYPTOGRAPHIC = "cryptographic"           # CWE-327, CWE-326
    CONFIGURATION = "configuration"           # CWE-16, CWE-2
    BUSINESS_LOGIC = "business_logic"         # CWE-840, CWE-841
    DATA_VALIDATION = "data_validation"       # CWE-20, CWE-79
    ERROR_HANDLING = "error_handling"         # CWE-209, CWE-248
    LOGGING_MONITORING = "logging_monitoring" # CWE-778, CWE-117
    NETWORK_SECURITY = "network_security"     # Network-level issues
    INFRASTRUCTURE = "infrastructure"         # System/OS level
    APPLICATION = "application"               # App-specific issues
    WEB_APPLICATION = "web_application"       # Web-specific issues
    API_SECURITY = "api_security"             # API-specific issues
    MOBILE = "mobile"                         # Mobile app issues
    IOT = "iot"                              # IoT device issues
    CLOUD = "cloud"                          # Cloud configuration issues


class RemediationPriority(Enum):
    """Remediation priority levels."""
    IMMEDIATE = "immediate"     # < 24 hours
    HIGH = "high"              # < 7 days
    MEDIUM = "medium"          # < 30 days
    LOW = "low"                # < 90 days
    PLANNING = "planning"      # > 90 days


@dataclass
class VulnerabilityEvidence:
    """Evidence supporting vulnerability discovery."""
    evidence_type: str  # screenshot, log, response, payload
    content: str
    timestamp: float = field(default_factory=time.time)
    source: str = "xorb"
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class RemediationStep:
    """Individual remediation step."""
    step_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    title: str = ""
    description: str = ""
    category: str = "manual"  # manual, automated, verification
    estimated_effort_hours: float = 1.0
    
    # Dependencies
    depends_on: List[str] = field(default_factory=list)
    
    # Automation
    automated: bool = False
    automation_script: Optional[str] = None
    
    # Status
    status: str = "pending"  # pending, in_progress, completed, failed, skipped
    assigned_to: Optional[str] = None
    started_at: Optional[float] = None
    completed_at: Optional[float] = None
    
    # Results
    output: Optional[str] = None
    success: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class Vulnerability:
    """Comprehensive vulnerability data structure."""
    # Core identification
    vuln_id: str = field(default_factory=lambda: f"XORB-{str(uuid.uuid4())[:8].upper()}")
    title: str = ""
    description: str = ""
    
    # Classification
    severity: VulnerabilitySeverity = VulnerabilitySeverity.MEDIUM
    cvss_score: float = 0.0
    cvss_vector: Optional[str] = None
    category: VulnerabilityCategory = VulnerabilityCategory.APPLICATION
    cwe_id: Optional[str] = None
    cve_id: Optional[str] = None
    
    # Asset information
    target_id: str = ""
    target_name: str = ""
    target_type: str = "unknown"  # web, api, network, host, application
    affected_component: str = ""
    location: str = ""  # URL, IP, file path, etc.
    
    # Discovery information
    discovered_by: str = "xorb"
    discovered_at: float = field(default_factory=time.time)
    discovery_method: str = "automated"
    scanner_details: Dict[str, Any] = field(default_factory=dict)
    
    # Evidence
    evidence: List[VulnerabilityEvidence] = field(default_factory=list)
    
    # Lifecycle
    state: VulnerabilityState = VulnerabilityState.DISCOVERED
    state_history: List[Dict[str, Any]] = field(default_factory=list)
    
    # Assignment and ownership
    assigned_to: Optional[str] = None
    assigned_at: Optional[float] = None
    team: Optional[str] = None
    
    # Remediation
    remediation_priority: RemediationPriority = RemediationPriority.MEDIUM
    remediation_steps: List[RemediationStep] = field(default_factory=list)
    remediation_notes: str = ""
    
    # SLA tracking
    sla_due_date: Optional[float] = None
    sla_violated: bool = False
    
    # Business impact
    business_impact: str = "medium"  # low, medium, high, critical
    affected_users: int = 0
    data_exposure_risk: bool = False
    
    # Verification
    verified: bool = False
    verified_by: Optional[str] = None
    verified_at: Optional[float] = None
    false_positive: bool = False
    
    # Resolution
    resolved_at: Optional[float] = None
    resolution_summary: str = ""
    resolution_verified: bool = False
    
    # Metadata
    tags: Set[str] = field(default_factory=set)
    external_refs: List[str] = field(default_factory=list)
    notes: str = ""
    
    # Tracking
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)
    
    def __post_init__(self):
        """Initialize vulnerability with calculated fields."""
        if not self.remediation_priority:
            self.remediation_priority = self._calculate_priority()
        
        if not self.sla_due_date:
            self.sla_due_date = self._calculate_sla_due_date()
        
        # Add initial state to history
        if not self.state_history:
            self.add_state_change(self.state, "Initial discovery")
    
    def _calculate_priority(self) -> RemediationPriority:
        """Calculate remediation priority based on severity and business impact."""
        if self.severity == VulnerabilitySeverity.CRITICAL:
            return RemediationPriority.IMMEDIATE
        elif self.severity == VulnerabilitySeverity.HIGH:
            if self.business_impact == "critical":
                return RemediationPriority.IMMEDIATE
            else:
                return RemediationPriority.HIGH
        elif self.severity == VulnerabilitySeverity.MEDIUM:
            if self.business_impact in ["critical", "high"]:
                return RemediationPriority.HIGH
            else:
                return RemediationPriority.MEDIUM
        else:
            return RemediationPriority.LOW
    
    def _calculate_sla_due_date(self) -> float:
        """Calculate SLA due date based on priority."""
        priority_hours = {
            RemediationPriority.IMMEDIATE: 24,
            RemediationPriority.HIGH: 7 * 24,
            RemediationPriority.MEDIUM: 30 * 24,
            RemediationPriority.LOW: 90 * 24,
            RemediationPriority.PLANNING: 180 * 24
        }
        
        hours = priority_hours.get(self.remediation_priority, 30 * 24)
        return self.discovered_at + (hours * 3600)
    
    def add_state_change(self, new_state: VulnerabilityState, reason: str = "", user: str = "system"):
        """Add state change to history."""
        old_state = self.state
        self.state = new_state
        self.updated_at = time.time()
        
        self.state_history.append({
            "timestamp": time.time(),
            "from_state": old_state.value if old_state else None,
            "to_state": new_state.value,
            "reason": reason,
            "user": user
        })
        
        # Update metrics
        VULNERABILITY_STATE_CHANGES.labels(
            from_state=old_state.value if old_state else "none",
            to_state=new_state.value
        ).inc()
    
    def add_evidence(self, evidence_type: str, content: str, source: str = "xorb", **metadata):
        """Add evidence to vulnerability."""
        evidence = VulnerabilityEvidence(
            evidence_type=evidence_type,
            content=content,
            source=source,
            metadata=metadata
        )
        self.evidence.append(evidence)
        self.updated_at = time.time()
    
    def is_sla_violated(self) -> bool:
        """Check if SLA is violated."""
        if self.sla_due_date and time.time() > self.sla_due_date:
            if not self.sla_violated:
                self.sla_violated = True
                SLA_VIOLATIONS.labels(severity=self.severity.value).inc()
            return True
        return False
    
    def get_age_days(self) -> float:
        """Get vulnerability age in days."""
        return (time.time() - self.discovered_at) / 86400
    
    def get_remediation_time(self) -> Optional[float]:
        """Get remediation time if resolved."""
        if self.resolved_at:
            return self.resolved_at - self.discovered_at
        return None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        data = asdict(self)
        data['tags'] = list(self.tags)
        return data


class IVulnerabilitySource(ABC):
    """Interface for vulnerability discovery sources."""
    
    @abstractmethod
    async def discover_vulnerabilities(self, target: Dict[str, Any]) -> List[Vulnerability]:
        """Discover vulnerabilities for a target."""
        pass
    
    @abstractmethod
    def get_source_name(self) -> str:
        """Get source name."""
        pass


class IRemediationProvider(ABC):
    """Interface for automated remediation providers."""
    
    @abstractmethod
    async def generate_remediation_steps(self, vulnerability: Vulnerability) -> List[RemediationStep]:
        """Generate remediation steps for a vulnerability."""
        pass
    
    @abstractmethod
    async def execute_remediation_step(self, step: RemediationStep, vulnerability: Vulnerability) -> bool:
        """Execute an automated remediation step."""
        pass
    
    @abstractmethod
    def supports_category(self, category: VulnerabilityCategory) -> bool:
        """Check if provider supports vulnerability category."""
        pass


class AutomatedRemediationProvider(IRemediationProvider):
    """Automated remediation provider for common vulnerabilities."""
    
    def __init__(self):
        self.remediation_templates = self._load_remediation_templates()
    
    def _load_remediation_templates(self) -> Dict[VulnerabilityCategory, List[Dict[str, Any]]]:
        """Load remediation templates for different vulnerability categories."""
        return {
            VulnerabilityCategory.INJECTION: [
                {
                    "title": "Implement Input Validation",
                    "description": "Add proper input validation and sanitization",
                    "category": "manual",
                    "estimated_effort_hours": 4.0
                },
                {
                    "title": "Use Parameterized Queries",
                    "description": "Replace dynamic SQL with parameterized queries",
                    "category": "manual",
                    "estimated_effort_hours": 2.0
                },
                {
                    "title": "Verify Fix",
                    "description": "Test the application to verify injection is prevented",
                    "category": "verification",
                    "estimated_effort_hours": 1.0
                }
            ],
            VulnerabilityCategory.AUTHENTICATION: [
                {
                    "title": "Implement Strong Authentication",
                    "description": "Add multi-factor authentication where appropriate",
                    "category": "manual",
                    "estimated_effort_hours": 8.0
                },
                {
                    "title": "Review Session Management",
                    "description": "Audit and improve session handling",
                    "category": "manual",
                    "estimated_effort_hours": 4.0
                }
            ],
            VulnerabilityCategory.CONFIGURATION: [
                {
                    "title": "Update Configuration",
                    "description": "Apply secure configuration settings",
                    "category": "automated",
                    "estimated_effort_hours": 0.5,
                    "automated": True
                },
                {
                    "title": "Verify Configuration",
                    "description": "Verify configuration changes are applied",
                    "category": "verification",
                    "estimated_effort_hours": 0.5
                }
            ]
        }
    
    async def generate_remediation_steps(self, vulnerability: Vulnerability) -> List[RemediationStep]:
        """Generate remediation steps based on vulnerability category."""
        templates = self.remediation_templates.get(vulnerability.category, [])
        steps = []
        
        for i, template in enumerate(templates):
            step = RemediationStep(
                title=template["title"],
                description=template["description"],
                category=template["category"],
                estimated_effort_hours=template["estimated_effort_hours"],
                automated=template.get("automated", False),
                automation_script=template.get("automation_script")
            )
            
            # Add dependency chain
            if i > 0:
                step.depends_on.append(steps[i-1].step_id)
            
            steps.append(step)
        
        return steps
    
    async def execute_remediation_step(self, step: RemediationStep, vulnerability: Vulnerability) -> bool:
        """Execute automated remediation step."""
        if not step.automated:
            return False
        
        try:
            step.status = "in_progress"
            step.started_at = time.time()
            
            # Simulate automated remediation
            if step.category == "automated" and vulnerability.category == VulnerabilityCategory.CONFIGURATION:
                # Example: automated configuration fix
                await asyncio.sleep(2)  # Simulate work
                step.output = "Configuration updated successfully"
                step.success = True
                step.status = "completed"
            else:
                step.output = "Automated remediation not implemented for this step type"
                step.success = False
                step.status = "failed"
            
            step.completed_at = time.time()
            return step.success
            
        except Exception as e:
            step.status = "failed"
            step.output = f"Automation failed: {str(e)}"
            step.completed_at = time.time()
            return False
    
    def supports_category(self, category: VulnerabilityCategory) -> bool:
        """Check if category is supported."""
        return category in self.remediation_templates


class WorkflowRule:
    """Vulnerability workflow rule."""
    
    def __init__(self, name: str, condition: Callable[[Vulnerability], bool], action: Callable[[Vulnerability], None]):
        self.name = name
        self.condition = condition
        self.action = action


class VulnerabilityLifecycleManager:
    """Main vulnerability lifecycle management system."""
    
    def __init__(self):
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.discovery_sources: List[IVulnerabilitySource] = []
        self.remediation_providers: List[IRemediationProvider] = []
        self.workflow_rules: List[WorkflowRule] = []
        self.running = False
        
        # Initialize default remediation provider
        self.add_remediation_provider(AutomatedRemediationProvider())
        
        # Setup default workflow rules
        self._setup_default_workflow_rules()
        
        # Statistics
        self.stats = {
            "vulnerabilities_processed": 0,
            "remediations_automated": 0,
            "sla_violations": 0,
            "false_positives": 0
        }
    
    def add_discovery_source(self, source: IVulnerabilitySource):
        """Add vulnerability discovery source."""
        self.discovery_sources.append(source)
        logger.info("Added vulnerability discovery source", source=source.get_source_name())
    
    def add_remediation_provider(self, provider: IRemediationProvider):
        """Add remediation provider."""
        self.remediation_providers.append(provider)
        logger.info("Added remediation provider", provider=type(provider).__name__)
    
    def _setup_default_workflow_rules(self):
        """Setup default workflow automation rules."""
        self.workflow_rules = [
            WorkflowRule(
                name="auto_triage_critical",
                condition=lambda v: v.severity == VulnerabilitySeverity.CRITICAL,
                action=lambda v: self._auto_triage_critical(v)
            ),
            WorkflowRule(
                name="auto_assign_by_category",
                condition=lambda v: v.state == VulnerabilityState.TRIAGED,
                action=lambda v: self._auto_assign_by_category(v)
            ),
            WorkflowRule(
                name="sla_violation_escalation",
                condition=lambda v: v.is_sla_violated(),
                action=lambda v: self._escalate_sla_violation(v)
            ),
            WorkflowRule(
                name="auto_close_verified",
                condition=lambda v: v.state == VulnerabilityState.VERIFIED and v.resolution_verified,
                action=lambda v: v.add_state_change(VulnerabilityState.CLOSED, "Automated closure after verification")
            )
        ]
    
    def _auto_triage_critical(self, vulnerability: Vulnerability):
        """Auto-triage critical vulnerabilities."""
        if vulnerability.state == VulnerabilityState.DISCOVERED:
            vulnerability.add_state_change(
                VulnerabilityState.CONFIRMED,
                "Auto-triaged due to critical severity"
            )
    
    def _auto_assign_by_category(self, vulnerability: Vulnerability):
        """Auto-assign vulnerabilities based on category."""
        category_teams = {
            VulnerabilityCategory.WEB_APPLICATION: "web_security_team",
            VulnerabilityCategory.API_SECURITY: "api_security_team",
            VulnerabilityCategory.INFRASTRUCTURE: "infrastructure_team",
            VulnerabilityCategory.NETWORK_SECURITY: "network_team"
        }
        
        team = category_teams.get(vulnerability.category)
        if team and not vulnerability.assigned_to:
            vulnerability.team = team
            vulnerability.assigned_at = time.time()
            vulnerability.add_state_change(
                VulnerabilityState.ASSIGNED,
                f"Auto-assigned to {team} based on category"
            )
    
    def _escalate_sla_violation(self, vulnerability: Vulnerability):
        """Escalate SLA violations."""
        if not vulnerability.sla_violated:
            vulnerability.sla_violated = True
            vulnerability.tags.add("sla_violated")
            vulnerability.tags.add("escalated")
            self.stats["sla_violations"] += 1
            
            logger.warning("SLA violation detected",
                         vuln_id=vulnerability.vuln_id,
                         severity=vulnerability.severity.value,
                         age_days=vulnerability.get_age_days())
    
    async def start_lifecycle_management(self):
        """Start the vulnerability lifecycle management system."""
        self.running = True
        
        # Start background tasks
        discovery_task = asyncio.create_task(self._discovery_loop())
        workflow_task = asyncio.create_task(self._workflow_loop())
        remediation_task = asyncio.create_task(self._remediation_loop())
        metrics_task = asyncio.create_task(self._metrics_loop())
        
        logger.info("Vulnerability lifecycle management started")
        
        try:
            await asyncio.gather(discovery_task, workflow_task, remediation_task, metrics_task)
        except asyncio.CancelledError:
            logger.info("Vulnerability lifecycle management stopped")
    
    async def stop_lifecycle_management(self):
        """Stop the lifecycle management system."""
        self.running = False
    
    async def _discovery_loop(self):
        """Run vulnerability discovery from all sources."""
        while self.running:
            try:
                await self._run_discovery()
                await asyncio.sleep(3600)  # Run discovery every hour
            except Exception as e:
                logger.error("Discovery loop failed", error=str(e))
                await asyncio.sleep(600)
    
    async def _workflow_loop(self):
        """Run workflow automation rules."""
        while self.running:
            try:
                await self._apply_workflow_rules()
                await asyncio.sleep(300)  # Run workflow rules every 5 minutes
            except Exception as e:
                logger.error("Workflow loop failed", error=str(e))
                await asyncio.sleep(300)
    
    async def _remediation_loop(self):
        """Run automated remediation steps."""
        while self.running:
            try:
                await self._process_remediation_queue()
                await asyncio.sleep(900)  # Process remediation every 15 minutes
            except Exception as e:
                logger.error("Remediation loop failed", error=str(e))
                await asyncio.sleep(900)
    
    async def _metrics_loop(self):
        """Update metrics and statistics."""
        while self.running:
            try:
                self._update_metrics()
                await asyncio.sleep(60)  # Update metrics every minute
            except Exception as e:
                logger.error("Metrics loop failed", error=str(e))
                await asyncio.sleep(60)
    
    async def _run_discovery(self):
        """Run vulnerability discovery."""
        # This would integrate with actual vulnerability scanners
        # For now, this is a placeholder that would connect to:
        # - OWASP ZAP
        # - Nessus
        # - Burp Suite Enterprise
        # - Custom XORB scanners
        pass
    
    async def _apply_workflow_rules(self):
        """Apply workflow automation rules to all vulnerabilities."""
        for vulnerability in self.vulnerabilities.values():
            for rule in self.workflow_rules:
                try:
                    if rule.condition(vulnerability):
                        rule.action(vulnerability)
                        logger.debug("Applied workflow rule",
                                   rule=rule.name,
                                   vuln_id=vulnerability.vuln_id)
                except Exception as e:
                    logger.error("Workflow rule failed",
                               rule=rule.name,
                               vuln_id=vulnerability.vuln_id,
                               error=str(e))
    
    async def _process_remediation_queue(self):
        """Process automated remediation steps."""
        for vulnerability in self.vulnerabilities.values():
            if vulnerability.state not in [VulnerabilityState.ASSIGNED, VulnerabilityState.IN_PROGRESS]:
                continue
            
            # Find pending automated steps
            for step in vulnerability.remediation_steps:
                if step.automated and step.status == "pending":
                    # Check dependencies
                    deps_complete = all(
                        any(s.step_id == dep_id and s.status == "completed" 
                            for s in vulnerability.remediation_steps)
                        for dep_id in step.depends_on
                    )
                    
                    if not step.depends_on or deps_complete:
                        await self._execute_remediation_step(step, vulnerability)
    
    async def _execute_remediation_step(self, step: RemediationStep, vulnerability: Vulnerability):
        """Execute a remediation step."""
        for provider in self.remediation_providers:
            if provider.supports_category(vulnerability.category):
                try:
                    success = await provider.execute_remediation_step(step, vulnerability)
                    if success:
                        self.stats["remediations_automated"] += 1
                        logger.info("Automated remediation step completed",
                                  vuln_id=vulnerability.vuln_id,
                                  step=step.title)
                    break
                except Exception as e:
                    logger.error("Remediation step failed",
                               vuln_id=vulnerability.vuln_id,
                               step=step.title,
                               error=str(e))
    
    def _update_metrics(self):
        """Update Prometheus metrics."""
        # Count active vulnerabilities by severity and category
        severity_counts = {}
        category_counts = {}
        
        for vuln in self.vulnerabilities.values():
            if vuln.state not in [VulnerabilityState.CLOSED, VulnerabilityState.FALSE_POSITIVE]:
                severity = vuln.severity.value
                category = vuln.category.value
                
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
                category_counts[category] = category_counts.get(category, 0) + 1
        
        # Update Prometheus gauges
        for severity in VulnerabilitySeverity:
            for category in VulnerabilityCategory:
                count = 0
                if severity.value in severity_counts and category.value in category_counts:
                    # Count vulnerabilities matching both severity and category
                    count = len([
                        v for v in self.vulnerabilities.values()
                        if v.severity == severity and v.category == category
                        and v.state not in [VulnerabilityState.CLOSED, VulnerabilityState.FALSE_POSITIVE]
                    ])
                
                ACTIVE_VULNERABILITIES.labels(
                    severity=severity.value,
                    category=category.value
                ).set(count)
    
    async def add_vulnerability(self, vulnerability: Vulnerability) -> str:
        """Add a new vulnerability to the system."""
        self.vulnerabilities[vulnerability.vuln_id] = vulnerability
        self.stats["vulnerabilities_processed"] += 1
        
        # Record discovery metric
        VULNERABILITY_DISCOVERED.labels(
            severity=vulnerability.severity.value,
            category=vulnerability.category.value
        ).inc()
        
        # Generate remediation steps if not present
        if not vulnerability.remediation_steps:
            await self._generate_remediation_steps(vulnerability)
        
        # Apply initial workflow rules
        for rule in self.workflow_rules:
            try:
                if rule.condition(vulnerability):
                    rule.action(vulnerability)
            except Exception as e:
                logger.error("Initial workflow rule failed",
                           rule=rule.name,
                           vuln_id=vulnerability.vuln_id,
                           error=str(e))
        
        logger.info("Vulnerability added to lifecycle management",
                   vuln_id=vulnerability.vuln_id,
                   severity=vulnerability.severity.value,
                   category=vulnerability.category.value)
        
        return vulnerability.vuln_id
    
    async def _generate_remediation_steps(self, vulnerability: Vulnerability):
        """Generate remediation steps for a vulnerability."""
        for provider in self.remediation_providers:
            if provider.supports_category(vulnerability.category):
                try:
                    steps = await provider.generate_remediation_steps(vulnerability)
                    vulnerability.remediation_steps.extend(steps)
                    break
                except Exception as e:
                    logger.error("Failed to generate remediation steps",
                               vuln_id=vulnerability.vuln_id,
                               provider=type(provider).__name__,
                               error=str(e))
    
    async def update_vulnerability_state(self, vuln_id: str, new_state: VulnerabilityState, 
                                       reason: str = "", user: str = "system") -> bool:
        """Update vulnerability state."""
        if vuln_id not in self.vulnerabilities:
            return False
        
        vulnerability = self.vulnerabilities[vuln_id]
        vulnerability.add_state_change(new_state, reason, user)
        
        # Record remediation time if resolved
        if new_state == VulnerabilityState.RESOLVED and vulnerability.resolved_at:
            remediation_time = vulnerability.get_remediation_time()
            if remediation_time:
                REMEDIATION_TIME.observe(remediation_time)
        
        return True
    
    def get_vulnerability(self, vuln_id: str) -> Optional[Vulnerability]:
        """Get vulnerability by ID."""
        return self.vulnerabilities.get(vuln_id)
    
    def get_vulnerabilities_by_state(self, state: VulnerabilityState) -> List[Vulnerability]:
        """Get vulnerabilities by state."""
        return [v for v in self.vulnerabilities.values() if v.state == state]
    
    def get_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity) -> List[Vulnerability]:
        """Get vulnerabilities by severity."""
        return [v for v in self.vulnerabilities.values() if v.severity == severity]
    
    def get_sla_violations(self) -> List[Vulnerability]:
        """Get vulnerabilities with SLA violations."""
        return [v for v in self.vulnerabilities.values() if v.is_sla_violated()]
    
    def get_system_statistics(self) -> Dict[str, Any]:
        """Get system statistics."""
        total_vulns = len(self.vulnerabilities)
        active_vulns = len([v for v in self.vulnerabilities.values() 
                           if v.state not in [VulnerabilityState.CLOSED, VulnerabilityState.FALSE_POSITIVE]])
        
        by_severity = {}
        by_category = {}
        by_state = {}
        
        for vuln in self.vulnerabilities.values():
            severity = vuln.severity.value
            category = vuln.category.value
            state = vuln.state.value
            
            by_severity[severity] = by_severity.get(severity, 0) + 1
            by_category[category] = by_category.get(category, 0) + 1
            by_state[state] = by_state.get(state, 0) + 1
        
        return {
            "total_vulnerabilities": total_vulns,
            "active_vulnerabilities": active_vulns,
            "by_severity": by_severity,
            "by_category": by_category,
            "by_state": by_state,
            "discovery_sources": len(self.discovery_sources),
            "remediation_providers": len(self.remediation_providers),
            "workflow_rules": len(self.workflow_rules),
            **self.stats
        }
    
    async def generate_vulnerability_report(self, timeframe_hours: int = 24) -> Dict[str, Any]:
        """Generate vulnerability report for a timeframe."""
        cutoff_time = time.time() - (timeframe_hours * 3600)
        
        recent_vulns = [
            v for v in self.vulnerabilities.values()
            if v.discovered_at >= cutoff_time
        ]
        
        report = {
            "timeframe_hours": timeframe_hours,
            "summary": {
                "total_discovered": len(recent_vulns),
                "critical": len([v for v in recent_vulns if v.severity == VulnerabilitySeverity.CRITICAL]),
                "high": len([v for v in recent_vulns if v.severity == VulnerabilitySeverity.HIGH]),
                "medium": len([v for v in recent_vulns if v.severity == VulnerabilitySeverity.MEDIUM]),
                "low": len([v for v in recent_vulns if v.severity == VulnerabilitySeverity.LOW])
            },
            "top_categories": {},
            "remediation_progress": {
                "resolved": len([v for v in recent_vulns if v.state == VulnerabilityState.RESOLVED]),
                "in_progress": len([v for v in recent_vulns if v.state == VulnerabilityState.IN_PROGRESS]),
                "pending": len([v for v in recent_vulns if v.state == VulnerabilityState.DISCOVERED])
            },
            "sla_status": {
                "violations": len([v for v in recent_vulns if v.is_sla_violated()]),
                "at_risk": len([v for v in recent_vulns 
                               if v.sla_due_date and v.sla_due_date - time.time() < 86400])
            }
        }
        
        # Top categories
        category_counts = {}
        for vuln in recent_vulns:
            category = vuln.category.value
            category_counts[category] = category_counts.get(category, 0) + 1
        
        report["top_categories"] = dict(sorted(category_counts.items(), 
                                             key=lambda x: x[1], reverse=True)[:10])
        
        return report


# Global vulnerability lifecycle manager
vulnerability_manager = VulnerabilityLifecycleManager()


async def initialize_vulnerability_management():
    """Initialize the vulnerability lifecycle management system."""
    await vulnerability_manager.start_lifecycle_management()


async def shutdown_vulnerability_management():
    """Shutdown the vulnerability management system."""
    await vulnerability_manager.stop_lifecycle_management()


def get_vulnerability_manager() -> VulnerabilityLifecycleManager:
    """Get the global vulnerability manager."""
    return vulnerability_manager