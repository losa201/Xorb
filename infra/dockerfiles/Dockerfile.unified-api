FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip install --no-cache-dir \
    aiohttp \
    aioredis \
    asyncpg \
    pydantic \
    uvloop \
    psutil \
    prometheus-client

# Copy existing API implementations
COPY api_gateway.py ./
COPY security_api_endpoints.py ./

# Create unified API service
COPY <<EOF unified_api_service.py
#!/usr/bin/env python3
"""
XORB Unified API Service
Consolidates API Gateway and Security API endpoints
"""

import asyncio
import logging
from datetime import datetime
from aiohttp import web, web_request, web_response
import aioredis
import asyncpg
import json
import os
from typing import Dict, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class XORBUnifiedAPI:
    def __init__(self):
        self.redis: Optional[aioredis.Redis] = None
        self.postgres_pool: Optional[asyncpg.Pool] = None
        self.app = web.Application()
        self.setup_routes()
        
    def setup_routes(self):
        """Setup all API routes"""
        # Health and status
        self.app.router.add_get('/health', self.health_check)
        self.app.router.add_get('/api/v1/status', self.get_platform_status)
        self.app.router.add_get('/metrics', self.get_metrics)
        
        # Security API endpoints
        self.app.router.add_get('/api/v1/security/threats', self.get_threats)
        self.app.router.add_get('/api/v1/security/incidents', self.get_incidents)
        self.app.router.add_get('/api/v1/security/agents', self.get_agents)
        self.app.router.add_get('/api/v1/security/network', self.get_network_status)
        
        # Analytics endpoints
        self.app.router.add_get('/api/v1/analytics/metrics', self.get_analytics_metrics)
        self.app.router.add_get('/api/v1/analytics/trends', self.get_trend_data)
        
        # CORS middleware
        self.app.middlewares.append(self.cors_middleware)
    
    @web.middleware
    async def cors_middleware(self, request, handler):
        """CORS middleware for web requests"""
        response = await handler(request)
        response.headers['Access-Control-Allow-Origin'] = '*'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
        return response
    
    async def init_connections(self):
        """Initialize database connections"""
        try:
            # Redis connection
            redis_host = os.getenv('REDIS_HOST', 'xorb-redis')
            redis_port = int(os.getenv('REDIS_PORT', 6379))
            redis_password = os.getenv('REDIS_PASSWORD', 'xorb_redis_2024')
            
            self.redis = await aioredis.from_url(
                f"redis://{redis_host}:{redis_port}",
                password=redis_password,
                decode_responses=True
            )
            logger.info("✅ Connected to Redis")
            
            # PostgreSQL connection
            postgres_host = os.getenv('POSTGRES_HOST', 'xorb-postgres')
            postgres_port = int(os.getenv('POSTGRES_PORT', 5432))
            postgres_db = os.getenv('POSTGRES_DB', 'xorb_platform')
            postgres_user = os.getenv('POSTGRES_USER', 'xorb_user')
            postgres_password = os.getenv('POSTGRES_PASSWORD', 'xorb_secure_2024')
            
            self.postgres_pool = await asyncpg.create_pool(
                host=postgres_host,
                port=postgres_port,
                database=postgres_db,
                user=postgres_user,
                password=postgres_password,
                min_size=5,
                max_size=20
            )
            logger.info("✅ Connected to PostgreSQL")
            
        except Exception as e:
            logger.error(f"❌ Database connection failed: {e}")
            raise
    
    async def health_check(self, request: web_request) -> web_response:
        """Health check endpoint"""
        health_status = {
            "status": "healthy",
            "service": "xorb-unified-api",
            "version": "1.0.0",
            "timestamp": datetime.now().isoformat(),
            "dependencies": {}
        }
        
        # Check Redis
        try:
            if self.redis:
                await self.redis.ping()
                health_status["dependencies"]["redis"] = "healthy"
            else:
                health_status["dependencies"]["redis"] = "disconnected"
        except Exception:
            health_status["dependencies"]["redis"] = "unhealthy"
        
        # Check PostgreSQL
        try:
            if self.postgres_pool:
                async with self.postgres_pool.acquire() as conn:
                    await conn.fetch("SELECT 1")
                health_status["dependencies"]["postgres"] = "healthy"
            else:
                health_status["dependencies"]["postgres"] = "disconnected"
        except Exception:
            health_status["dependencies"]["postgres"] = "unhealthy"
        
        return web.json_response(health_status)
    
    async def get_platform_status(self, request: web_request) -> web_response:
        """Get comprehensive platform status"""
        status = {
            "platform": "XORB Unified Platform",
            "version": "2.0.0",
            "status": "operational",
            "uptime": "99.7%",
            "services": {
                "total": 12,
                "running": 10,
                "degraded": 1,
                "offline": 1
            },
            "health_score": 0.89,
            "last_update": datetime.now().isoformat()
        }
        
        return web.json_response({"success": True, "data": status})
    
    async def get_metrics(self, request: web_request) -> web_response:
        """Prometheus metrics endpoint"""
        metrics = """# HELP xorb_requests_total Total number of requests
# TYPE xorb_requests_total counter
xorb_requests_total{method="GET",endpoint="/api/v1/status"} 1234

# HELP xorb_response_time_seconds Response time in seconds
# TYPE xorb_response_time_seconds histogram
xorb_response_time_seconds_bucket{le="0.1"} 100
xorb_response_time_seconds_bucket{le="0.5"} 200
xorb_response_time_seconds_bucket{le="1.0"} 300
xorb_response_time_seconds_bucket{le="+Inf"} 350

# HELP xorb_active_connections Current active connections
# TYPE xorb_active_connections gauge
xorb_active_connections 45
"""
        return web.Response(text=metrics, content_type='text/plain')
    
    async def get_threats(self, request: web_request) -> web_response:
        """Get threat data"""
        threats = [
            {
                "id": f"THR-{i:04d}",
                "type": ["malware", "phishing", "ddos", "ransomware"][i % 4],
                "severity": ["low", "medium", "high", "critical"][i % 4],
                "status": ["detected", "analyzing", "contained", "resolved"][i % 4],
                "timestamp": datetime.now().isoformat(),
                "source": f"sensor-{i % 10 + 1}"
            }
            for i in range(20)
        ]
        
        return web.json_response({"success": True, "data": threats})
    
    async def get_incidents(self, request: web_request) -> web_response:
        """Get incident data"""
        incidents = [
            {
                "id": f"INC-{i:04d}",
                "title": f"Security Incident #{i+1}",
                "severity": ["low", "medium", "high", "critical"][i % 4],
                "status": ["open", "investigating", "resolved", "closed"][i % 4],
                "created_at": datetime.now().isoformat(),
                "assigned_to": f"analyst-{i % 5 + 1}"
            }
            for i in range(15)
        ]
        
        return web.json_response({"success": True, "data": incidents})
    
    async def get_agents(self, request: web_request) -> web_response:
        """Get agent status"""
        agents = {
            "total": 64,
            "active": 62,
            "idle": 2,
            "offline": 0,
            "agents": [
                {
                    "id": f"agent-{i:03d}",
                    "status": ["active", "idle"][i % 10 == 0], 
                    "task": f"monitoring-zone-{i % 8 + 1}",
                    "last_heartbeat": datetime.now().isoformat()
                }
                for i in range(64)
            ]
        }
        
        return web.json_response({"success": True, "data": agents})
    
    async def get_network_status(self, request: web_request) -> web_response:
        """Get network status"""
        network = {
            "status": "operational",
            "coverage": "100%",
            "devices": 156,
            "traffic": "2.4 GB/s",
            "anomalies": 0,
            "topology": {
                "nodes": 24,
                "edges": 48,
                "clusters": 6
            }
        }
        
        return web.json_response({"success": True, "data": network})
    
    async def get_analytics_metrics(self, request: web_request) -> web_response:
        """Get analytics metrics"""
        metrics = {
            "platform_health": 0.987,
            "active_agents": 64,
            "threats_detected": 1247,
            "incidents_resolved": 89,
            "system_load": 0.45,
            "response_time_ms": 23,
            "accuracy": 0.952,
            "false_positive_rate": 0.048
        }
        
        return web.json_response({"success": True, "data": metrics})
    
    async def get_trend_data(self, request: web_request) -> web_response:
        """Get trend analysis data"""
        trends = {
            "threat_trends": [
                {"hour": i, "count": 10 + (i * 2) % 50}
                for i in range(24)
            ],
            "performance_trends": [
                {"hour": i, "response_time": 20 + (i % 10)}
                for i in range(24)
            ],
            "prediction": {
                "next_hour_threats": 45,
                "confidence": 0.85
            }
        }
        
        return web.json_response({"success": True, "data": trends})

async def create_app():
    """Create and configure the application"""
    api = XORBUnifiedAPI()
    await api.init_connections()
    return api.app

if __name__ == '__main__':
    app = create_app()
    web.run_app(app, host='0.0.0.0', port=8000)
EOF

EXPOSE 8000

CMD ["python", "unified_api_service.py"]