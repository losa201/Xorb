from typing import Dict, List, Any, Optional

#!/usr/bin/env python3
"""
Vulnerability Lifecycle Management Demonstration

This script demonstrates the comprehensive vulnerability lifecycle management
capabilities including discovery, automated triage, remediation workflow,
and lifecycle tracking.
"""

import asyncio
import json
import random
import time
from pathlib import Path
import sys

# Add the xorb_core to Python path
sys.path.insert(0, str(Path(__file__).parent.parent))

from xorb_core.vulnerabilities import (
    Vulnerability,
    VulnerabilityState,
    VulnerabilitySeverity, 
    VulnerabilityCategory,
    RemediationPriority,
    VulnerabilityEvidence,
    RemediationStep,
    vulnerability_manager
)
from xorb_core.logging.audit_system import logging_system, AuditEventType, LogLevel

import structlog

logger = structlog.get_logger(__name__)


class VulnerabilityLifecycleDemo:
    """Comprehensive vulnerability lifecycle demonstration."""
    
    def __init__(self) -> None:
        self.demo_vulnerabilities = []
        
    async def run_demo(self) -> None:
        """Run the complete vulnerability lifecycle demonstration."""
        print("🔍 VULNERABILITY LIFECYCLE MANAGEMENT DEMONSTRATION")
        print("=" * 65)
        print("This demo showcases comprehensive vulnerability management:")
        print("• Vulnerability discovery and classification")
        print("• Automated triage and workflow automation")
        print("• Remediation step generation and execution")
        print("• SLA tracking and violation management")
        print("• Lifecycle state management and reporting")
        print("=" * 65)
        
        try:
            # Start the vulnerability management system
            await self._initialize_system()
            
            # Run demonstration scenarios
            await self._demo_vulnerability_discovery()
            await self._demo_automated_triage()
            await self._demo_remediation_workflow()
            await self._demo_sla_management()
            await self._demo_lifecycle_tracking()
            await self._demo_reporting()
            
            # Generate final report
            await self._generate_summary_report()
            
        except Exception as e:
            print(f"❌ Demo failed: {e}")
            import traceback
            traceback.print_exc()
        finally:
            await self._cleanup_system()
    
    async def _initialize_system(self) -> None:
        """Initialize the vulnerability management system."""
        print("\n🚀 Initializing Vulnerability Management System...")
        
        # Start the vulnerability manager (in demo mode - no background loops)
        vulnerability_manager.running = True
        
        print("✅ Vulnerability management system initialized")
    
    async def _demo_vulnerability_discovery(self) -> None:
        """Demonstrate vulnerability discovery and classification."""
        print("\n🔍 VULNERABILITY DISCOVERY DEMONSTRATION")
        print("-" * 50)
        
        # Create sample vulnerabilities representing different scenarios
        sample_vulns = [
            {
                "title": "SQL Injection in User Login",
                "description": "User input not properly sanitized in login form allowing SQL injection",
                "severity": VulnerabilitySeverity.HIGH,
                "cvss_score": 8.1,
                "category": VulnerabilityCategory.INJECTION,
                "cwe_id": "CWE-89",
                "target_name": "WebApp Production",
                "location": "https://app.example.com/login",
                "business_impact": "high",
                "affected_users": 15000
            },
            {
                "title": "Weak SSL/TLS Configuration",
                "description": "Server supports weak TLS versions and cipher suites",
                "severity": VulnerabilitySeverity.MEDIUM,
                "cvss_score": 5.3,
                "category": VulnerabilityCategory.CRYPTOGRAPHIC,
                "cwe_id": "CWE-327",
                "target_name": "API Gateway",
                "location": "https://api.example.com",
                "business_impact": "medium",
                "affected_users": 5000
            },
            {
                "title": "Critical Remote Code Execution",
                "description": "Unauthenticated remote code execution in admin panel",
                "severity": VulnerabilitySeverity.CRITICAL,
                "cvss_score": 9.8,
                "category": VulnerabilityCategory.ACCESS_CONTROL,
                "cwe_id": "CWE-862",
                "target_name": "Admin Portal",
                "location": "https://admin.example.com/exec",
                "business_impact": "critical",
                "data_exposure_risk": True,
                "affected_users": 100
            },
            {
                "title": "Insecure Direct Object Reference",
                "description": "User can access other users' data by manipulating object references",
                "severity": VulnerabilitySeverity.HIGH,
                "cvss_score": 7.5,
                "category": VulnerabilityCategory.ACCESS_CONTROL,
                "cwe_id": "CWE-639",
                "target_name": "User Dashboard",
                "location": "https://app.example.com/user/profile",
                "business_impact": "high",
                "data_exposure_risk": True,
                "affected_users": 8000
            },
            {
                "title": "Missing Security Headers",
                "description": "Web application missing security headers (CSP, HSTS, etc.)",
                "severity": VulnerabilitySeverity.LOW,
                "cvss_score": 3.1,
                "category": VulnerabilityCategory.CONFIGURATION,
                "cwe_id": "CWE-16",
                "target_name": "Public Website",
                "location": "https://www.example.com",
                "business_impact": "low",
                "affected_users": 50000
            }
        ]
        
        print("📋 Discovering vulnerabilities...")
        
        for vuln_data in sample_vulns:
            # Create vulnerability object
            vuln = Vulnerability(
                title=vuln_data["title"],
                description=vuln_data["description"],
                severity=vuln_data["severity"],
                cvss_score=vuln_data["cvss_score"],
                category=vuln_data["category"],
                cwe_id=vuln_data.get("cwe_id"),
                target_name=vuln_data["target_name"],
                location=vuln_data["location"],
                business_impact=vuln_data["business_impact"],
                affected_users=vuln_data.get("affected_users", 0),
                data_exposure_risk=vuln_data.get("data_exposure_risk", False)
            )
            
            # Add evidence
            vuln.add_evidence(
                "scanner_output",
                f"Vulnerability detected by automated scanner",
                source="xorb_scanner",
                confidence=0.9
            )
            
            # Add to vulnerability manager
            vuln_id = await vulnerability_manager.add_vulnerability(vuln)
            self.demo_vulnerabilities.append(vuln_id)
            
            print(f"   • {vuln.severity.value.upper()}: {vuln.title}")
            print(f"     ID: {vuln_id}, CVSS: {vuln.cvss_score}, Category: {vuln.category.value}")
        
        print(f"\n✅ Discovered {len(sample_vulns)} vulnerabilities")
    
    async def _demo_automated_triage(self) -> None:
        """Demonstrate automated triage and workflow automation."""
        print("\n⚙️ AUTOMATED TRIAGE DEMONSTRATION")
        print("-" * 50)
        
        print("🤖 Applying automated triage rules...")
        
        # Apply workflow rules to all vulnerabilities
        await vulnerability_manager._apply_workflow_rules()
        
        # Show triage results
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                print(f"   • {vuln.title[:50]}...")
                print(f"     State: {vuln.state.value}")
                print(f"     Priority: {vuln.remediation_priority.value}")
                if vuln.team:
                    print(f"     Assigned Team: {vuln.team}")
                print(f"     SLA Due: {time.strftime('%Y-%m-%d %H:%M', time.localtime(vuln.sla_due_date))}")
        
        print("\n✅ Automated triage completed")
    
    async def _demo_remediation_workflow(self) -> None:
        """Demonstrate remediation workflow and automation."""
        print("\n🔧 REMEDIATION WORKFLOW DEMONSTRATION")
        print("-" * 50)
        
        print("📋 Generating remediation steps...")
        
        # Show remediation steps for each vulnerability
        for vuln_id in self.demo_vulnerabilities[:3]:  # Show first 3 for brevity
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln and vuln.remediation_steps:
                print(f"\n🎯 {vuln.title}")
                print(f"   Remediation Steps ({len(vuln.remediation_steps)} total):")
                
                for i, step in enumerate(vuln.remediation_steps, 1):
                    print(f"   {i}. {step.title}")
                    print(f"      Type: {step.category}, Effort: {step.estimated_effort_hours}h")
                    if step.automated:
                        print(f"      🤖 Automated step")
                    if step.depends_on:
                        print(f"      Dependencies: {len(step.depends_on)} step(s)")
        
        print("\n🤖 Executing automated remediation steps...")
        
        # Simulate automated remediation execution
        await vulnerability_manager._process_remediation_queue()
        
        # Show execution results
        automation_count = 0
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                for step in vuln.remediation_steps:
                    if step.automated and step.status == "completed":
                        automation_count += 1
                        print(f"   ✅ Automated: {step.title}")
        
        print(f"\n✅ Remediation workflow processed, {automation_count} automated steps executed")
    
    async def _demo_sla_management(self) -> None:
        """Demonstrate SLA tracking and violation management."""
        print("\n⏰ SLA MANAGEMENT DEMONSTRATION")
        print("-" * 50)
        
        # Simulate some SLA violations by manipulating discovery times
        critical_vuln = None
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln and vuln.severity == VulnerabilitySeverity.CRITICAL:
                critical_vuln = vuln
                break
        
        if critical_vuln:
            # Simulate an older critical vulnerability that would violate SLA
            original_time = critical_vuln.discovered_at
            critical_vuln.discovered_at = time.time() - (25 * 3600)  # 25 hours ago
            critical_vuln.sla_due_date = critical_vuln.discovered_at + (24 * 3600)  # 24 hour SLA
            
            print("🚨 Simulating SLA violation scenario...")
            print(f"   Critical vulnerability: {critical_vuln.title}")
            print(f"   Discovered: {time.strftime('%Y-%m-%d %H:%M', time.localtime(critical_vuln.discovered_at))}")
            print(f"   SLA Due: {time.strftime('%Y-%m-%d %H:%M', time.localtime(critical_vuln.sla_due_date))}")
            print(f"   Age: {critical_vuln.get_age_days():.1f} days")
            
            # Check SLA violation
            if critical_vuln.is_sla_violated():
                print("   ❌ SLA VIOLATED")
            else:
                print("   ✅ Within SLA")
            
            # Apply SLA escalation workflow
            await vulnerability_manager._apply_workflow_rules()
            
            if "sla_violated" in critical_vuln.tags:
                print("   🚨 Automatically escalated due to SLA violation")
            
            # Restore original time
            critical_vuln.discovered_at = original_time
            critical_vuln.sla_due_date = critical_vuln._calculate_sla_due_date()
        
        # Show SLA status for all vulnerabilities
        print("\n📊 SLA Status Summary:")
        sla_violations = vulnerability_manager.get_sla_violations()
        print(f"   • SLA Violations: {len(sla_violations)}")
        
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                time_remaining = (vuln.sla_due_date - time.time()) / 3600 if vuln.sla_due_date else 0
                status = "⏰ At Risk" if 0 < time_remaining < 24 else "✅ OK" if time_remaining > 0 else "❌ Violated"
                print(f"   • {vuln.severity.value.upper()}: {status} ({time_remaining:.1f}h remaining)")
        
        print("\n✅ SLA management demonstration completed")
    
    async def _demo_lifecycle_tracking(self) -> None:
        """Demonstrate vulnerability lifecycle state tracking."""
        print("\n📊 LIFECYCLE TRACKING DEMONSTRATION")
        print("-" * 50)
        
        print("🔄 Simulating vulnerability lifecycle progression...")
        
        # Progress some vulnerabilities through different states
        state_progression = [
            (VulnerabilityState.TRIAGED, "Manual triage completed"),
            (VulnerabilityState.CONFIRMED, "Vulnerability confirmed by security team"),
            (VulnerabilityState.ASSIGNED, "Assigned to development team"),
            (VulnerabilityState.IN_PROGRESS, "Development team working on fix"),
            (VulnerabilityState.TESTING, "Fix implemented, testing in progress"),
            (VulnerabilityState.RESOLVED, "Fix deployed to production"),
            (VulnerabilityState.VERIFIED, "Fix verified by security team"),
            (VulnerabilityState.CLOSED, "Vulnerability lifecycle completed")
        ]
        
        # Progress first vulnerability through complete lifecycle
        if self.demo_vulnerabilities:
            vuln_id = self.demo_vulnerabilities[0]
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            
            print(f"\n📈 Progressing: {vuln.title}")
            
            for state, reason in state_progression:
                await vulnerability_manager.update_vulnerability_state(vuln_id, state, reason, "demo_user")
                print(f"   • {state.value}: {reason}")
                await asyncio.sleep(0.1)  # Small delay for demonstration
        
        # Progress second vulnerability partially
        if len(self.demo_vulnerabilities) > 1:
            vuln_id = self.demo_vulnerabilities[1]
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            
            print(f"\n📈 Partially progressing: {vuln.title}")
            
            for state, reason in state_progression[:4]:  # Only progress through first 4 states
                await vulnerability_manager.update_vulnerability_state(vuln_id, state, reason, "demo_user")
                print(f"   • {state.value}: {reason}")
        
        # Show state distribution
        print("\n📊 Current State Distribution:")
        by_state = {}
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                state = vuln.state.value
                by_state[state] = by_state.get(state, 0) + 1
        
        for state, count in by_state.items():
            print(f"   • {state}: {count} vulnerabilities")
        
        print("\n✅ Lifecycle tracking demonstration completed")
    
    async def _demo_reporting(self) -> None:
        """Demonstrate vulnerability reporting capabilities."""
        print("\n📈 REPORTING DEMONSTRATION")
        print("-" * 50)
        
        print("📊 Generating vulnerability reports...")
        
        # Get system statistics
        stats = vulnerability_manager.get_system_statistics()
        
        print(f"\n📋 System Overview:")
        print(f"   • Total Vulnerabilities: {stats['total_vulnerabilities']}")
        print(f"   • Active Vulnerabilities: {stats['active_vulnerabilities']}")
        print(f"   • Discovery Sources: {stats['discovery_sources']}")
        print(f"   • Remediation Providers: {stats['remediation_providers']}")
        print(f"   • Automated Remediations: {stats['remediations_automated']}")
        
        print(f"\n🎯 By Severity:")
        for severity, count in stats.get('by_severity', {}).items():
            print(f"   • {severity.upper()}: {count}")
        
        print(f"\n📂 By Category:")
        top_categories = sorted(stats.get('by_category', {}).items(), key=lambda x: x[1], reverse=True)[:5]
        for category, count in top_categories:
            print(f"   • {category.replace('_', ' ').title()}: {count}")
        
        print(f"\n🔄 By State:")
        for state, count in stats.get('by_state', {}).items():
            print(f"   • {state.replace('_', ' ').title()}: {count}")
        
        # Generate detailed report
        report = await vulnerability_manager.generate_vulnerability_report(timeframe_hours=24)
        
        print(f"\n📈 24-Hour Activity Report:")
        print(f"   • New Discoveries: {report['summary']['total_discovered']}")
        print(f"   • Critical: {report['summary']['critical']}")
        print(f"   • High: {report['summary']['high']}")
        print(f"   • Medium: {report['summary']['medium']}")
        print(f"   • Low: {report['summary']['low']}")
        
        print(f"\n🔧 Remediation Progress:")
        progress = report['remediation_progress']
        print(f"   • Resolved: {progress['resolved']}")
        print(f"   • In Progress: {progress['in_progress']}")
        print(f"   • Pending: {progress['pending']}")
        
        print(f"\n⏰ SLA Status:")
        sla_status = report['sla_status']
        print(f"   • Violations: {sla_status['violations']}")
        print(f"   • At Risk: {sla_status['at_risk']}")
        
        print("\n✅ Reporting demonstration completed")
    
    async def _generate_summary_report(self) -> None:
        """Generate comprehensive summary report."""
        print("\n📊 COMPREHENSIVE SUMMARY REPORT")
        print("=" * 50)
        
        stats = vulnerability_manager.get_system_statistics()
        
        print(f"🎯 Vulnerability Management System Summary:")
        print(f"   • Vulnerabilities Processed: {stats['vulnerabilities_processed']}")
        print(f"   • Automated Remediations: {stats['remediations_automated']}")
        print(f"   • SLA Violations: {stats['sla_violations']}")
        print(f"   • False Positives: {stats['false_positives']}")
        
        print(f"\n🔧 System Capabilities:")
        print(f"   • ✅ Automated vulnerability discovery and classification")
        print(f"   • ✅ Intelligent triage and workflow automation")
        print(f"   • ✅ Remediation step generation and tracking")
        print(f"   • ✅ SLA management and violation detection")
        print(f"   • ✅ Complete lifecycle state management")
        print(f"   • ✅ Comprehensive reporting and analytics")
        
        print(f"\n📈 Business Value:")
        print(f"   • Reduced manual triage effort through automation")
        print(f"   • Improved remediation tracking and accountability")
        print(f"   • Proactive SLA violation prevention")
        print(f"   • Enhanced visibility into vulnerability landscape")
        print(f"   • Streamlined security team workflows")
        
        print(f"\n✅ VULNERABILITY LIFECYCLE MANAGEMENT DEMONSTRATION COMPLETE")
        print(f"All advanced vulnerability management capabilities successfully demonstrated!")
    
    async def _cleanup_system(self) -> None:
        """Clean up the demonstration system."""
        print("\n🧹 Cleaning up demonstration...")
        vulnerability_manager.running = False
        print("✅ Cleanup completed")


async def main() -> None:
    """Main demonstration function."""
    demo = VulnerabilityLifecycleDemo()
    await demo.run_demo()


if __name__ == "__main__":
    asyncio.run(main())