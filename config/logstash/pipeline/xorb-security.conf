# XORB Platform Security Event Processing Pipeline
# Advanced SIEM configuration for real-time threat detection

input {
  # Beats input for log aggregation
  beats {
    port => 5044
    ssl => true
    ssl_certificate => "/usr/share/logstash/config/certs/logstash.pem"
    ssl_key => "/usr/share/logstash/config/certs/logstash-key.pem"
    ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.pem"]
  }

  # TCP input for application logs
  tcp {
    port => 5000
    codec => json_lines
    tags => ["tcp_input"]
  }

  # HTTP input for webhook events
  http {
    port => 8080
    codec => json
    tags => ["webhook"]
  }
}

filter {
  # Parse JSON logs
  if [fields][log_type] == "application" {
    json {
      source => "message"
    }
  }

  # XORB API Security Events
  if [container][name] =~ /xorb-api/ {
    mutate {
      add_tag => ["xorb-api", "security"]
    }

    # Parse security events
    if [level] == "WARNING" or [level] == "ERROR" {
      mutate {
        add_tag => ["security_alert"]
      }
    }

    # Authentication events
    if [message] =~ /authentication|login|logout|token/ {
      mutate {
        add_tag => ["authentication"]
      }
      
      # Extract authentication details
      grok {
        match => { 
          "message" => "(?<auth_action>login|logout|token_.*) .*user_id=(?<user_id>[^ ]+)" 
        }
        tag_on_failure => ["auth_parse_failed"]
      }
    }

    # Rate limiting events
    if [message] =~ /rate.?limit/ {
      mutate {
        add_tag => ["rate_limiting", "potential_attack"]
      }
      
      grok {
        match => { 
          "message" => "Rate limit.*key=(?<rate_limit_key>[^ ]+).*attempts=(?<attempts>[0-9]+)" 
        }
      }
    }

    # JWT token events
    if [message] =~ /token.*(expired|invalid|revoked)/ {
      mutate {
        add_tag => ["jwt_security", "token_issue"]
      }
    }

    # SQL injection attempts
    if [message] =~ /(union|select|drop|insert|update|delete).*(from|where|table)/i {
      mutate {
        add_tag => ["sql_injection", "high_severity"]
        add_field => { "threat_type" => "SQL Injection" }
        add_field => { "severity" => "HIGH" }
      }
    }

    # XSS attempts
    if [message] =~ /<script|javascript:|on\w+\s*=/i {
      mutate {
        add_tag => ["xss_attempt", "high_severity"]
        add_field => { "threat_type" => "Cross-Site Scripting" }
        add_field => { "severity" => "HIGH" }
      }
    }

    # Command injection attempts
    if [message] =~ /(;|\||\&)\s*(cat|ls|ps|whoami|id|uname|curl|wget)/i {
      mutate {
        add_tag => ["command_injection", "critical_severity"]
        add_field => { "threat_type" => "Command Injection" }
        add_field => { "severity" => "CRITICAL" }
      }
    }

    # File upload security
    if [message] =~ /file.*upload.*malicious/ {
      mutate {
        add_tag => ["malicious_upload", "high_severity"]
        add_field => { "threat_type" => "Malicious File Upload" }
        add_field => { "severity" => "HIGH" }
      }
    }
  }

  # Exploit Validation Engine Events
  if [logger_name] =~ /exploit_validation/ {
    mutate {
      add_tag => ["exploit_validation", "security"]
    }

    # Validation failures
    if [message] =~ /validation.*rejected|safety.*violation/ {
      mutate {
        add_tag => ["validation_rejection", "security_control"]
        add_field => { "security_action" => "blocked" }
      }
    }

    # Threat detections
    if [message] =~ /threat.*detected|signature.*match/ {
      mutate {
        add_tag => ["threat_detected", "high_severity"]
        add_field => { "threat_type" => "Known Exploit Signature" }
        add_field => { "severity" => "HIGH" }
      }
    }
  }

  # Container Security Events
  if [container][name] {
    mutate {
      add_tag => ["container_logs"]
    }

    # Container runtime security
    if [message] =~ /(privilege.*escalation|container.*escape|unauthorized.*access)/i {
      mutate {
        add_tag => ["container_security", "critical_severity"]
        add_field => { "threat_type" => "Container Security Violation" }
        add_field => { "severity" => "CRITICAL" }
      }
    }
  }

  # Network Security Events
  if [agent][type] == "auditbeat" {
    mutate {
      add_tag => ["network_security", "system_audit"]
    }

    # Suspicious network connections
    if [destination][port] in [22, 23, 135, 139, 445, 1433, 3389] {
      mutate {
        add_tag => ["suspicious_port", "potential_attack"]
      }
    }

    # Process execution monitoring
    if [event][action] == "executed" {
      # Suspicious commands
      if [process][name] in ["nc", "netcat", "nmap", "sqlmap", "metasploit"] {
        mutate {
          add_tag => ["suspicious_process", "high_severity"]
          add_field => { "threat_type" => "Suspicious Process Execution" }
          add_field => { "severity" => "HIGH" }
        }
      }
    }
  }

  # GeoIP enrichment for external IPs
  if [source][ip] and [source][ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
    geoip {
      source => "[source][ip]"
      target => "[@metadata][geoip]"
    }

    # Add geographic information
    if [@metadata][geoip] {
      mutate {
        add_field => {
          "[source][geo][country_name]" => "%{[@metadata][geoip][country_name]}"
          "[source][geo][city_name]" => "%{[@metadata][geoip][city_name]}"
          "[source][geo][continent_code]" => "%{[@metadata][geoip][continent_code]}"
          "[source][geo][location][lat]" => "%{[@metadata][geoip][latitude]}"
          "[source][geo][location][lon]" => "%{[@metadata][geoip][longitude]}"
        }
      }
    }
  }

  # Risk scoring based on threat indicators
  ruby {
    code => "
      risk_score = 0
      
      # Base risk factors
      risk_score += 10 if event.get('tags')&.include?('high_severity')
      risk_score += 20 if event.get('tags')&.include?('critical_severity')
      risk_score += 5 if event.get('tags')&.include?('authentication')
      risk_score += 15 if event.get('tags')&.include?('potential_attack')
      risk_score += 25 if event.get('tags')&.include?('sql_injection')
      risk_score += 20 if event.get('tags')&.include?('xss_attempt')
      risk_score += 30 if event.get('tags')&.include?('command_injection')
      risk_score += 15 if event.get('tags')&.include?('container_security')
      
      # Geographic risk (non-US/EU)
      continent = event.get('[source][geo][continent_code]')
      if continent && !['NA', 'EU'].include?(continent)
        risk_score += 10
      end
      
      # Multiple failed attempts
      attempts = event.get('attempts')
      if attempts && attempts.to_i > 5
        risk_score += 15
      end
      
      event.set('risk_score', risk_score)
      
      # Risk classification
      if risk_score >= 50
        event.set('risk_level', 'CRITICAL')
      elsif risk_score >= 30
        event.set('risk_level', 'HIGH')
      elsif risk_score >= 15
        event.set('risk_level', 'MEDIUM')
      else
        event.set('risk_level', 'LOW')
      end
    "
  }

  # Add timestamp and processing metadata
  mutate {
    add_field => {
      "[@metadata][processed_at]" => "%{+yyyy-MM-dd'T'HH:mm:ss.SSSZ}"
      "[@metadata][pipeline_version]" => "1.0"
      "[@metadata][platform]" => "XORB"
    }
  }

  # Clean up fields
  mutate {
    remove_field => ["@version", "host", "agent.version", "ecs.version"]
  }
}

output {
  # High-priority security alerts to dedicated index
  if "critical_severity" in [tags] or "high_severity" in [tags] or [risk_score] >= 30 {
    elasticsearch {
      hosts => ["https://elasticsearch:9200"]
      index => "xorb-security-alerts-%{+yyyy.MM.dd}"
      user => "logstash_internal"
      password => "${ELASTIC_PASSWORD}"
      ssl => true
      ssl_certificate_verification => true
      ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.pem"]
      template_name => "xorb-security-alerts"
      template_pattern => "xorb-security-alerts-*"
      template => "/usr/share/logstash/templates/security-alerts-template.json"
    }
  }

  # Authentication events to dedicated index
  if "authentication" in [tags] {
    elasticsearch {
      hosts => ["https://elasticsearch:9200"]
      index => "xorb-authentication-%{+yyyy.MM.dd}"
      user => "logstash_internal"
      password => "${ELASTIC_PASSWORD}"
      ssl => true
      ssl_certificate_verification => true
      ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.pem"]
    }
  }

  # API access logs
  if "xorb-api" in [tags] {
    elasticsearch {
      hosts => ["https://elasticsearch:9200"]
      index => "xorb-api-logs-%{+yyyy.MM.dd}"
      user => "logstash_internal"
      password => "${ELASTIC_PASSWORD}"
      ssl => true
      ssl_certificate_verification => true
      ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.pem"]
    }
  }

  # All security events to main index
  elasticsearch {
    hosts => ["https://elasticsearch:9200"]
    index => "xorb-security-%{+yyyy.MM.dd}"
    user => "logstash_internal"
    password => "${ELASTIC_PASSWORD}"
    ssl => true
    ssl_certificate_verification => true
    ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.pem"]
    template_name => "xorb-security"
    template_pattern => "xorb-security-*"
    template => "/usr/share/logstash/templates/security-template.json"
  }

  # Critical alerts to external SIEM/SOAR
  if [risk_level] == "CRITICAL" {
    http {
      url => "${EXTERNAL_SIEM_WEBHOOK_URL}"
      http_method => "post"
      headers => {
        "Authorization" => "Bearer ${EXTERNAL_SIEM_TOKEN}"
        "Content-Type" => "application/json"
      }
      format => "json"
      mapping => {
        "alert_id" => "%{[@metadata][uuid]}"
        "timestamp" => "%{@timestamp}"
        "platform" => "XORB"
        "severity" => "%{severity}"
        "threat_type" => "%{threat_type}"
        "risk_score" => "%{risk_score}"
        "source_ip" => "%{[source][ip]}"
        "message" => "%{message}"
        "tags" => "%{tags}"
      }
    }
  }

  # Debug output for development
  if [@metadata][debug] {
    stdout { 
      codec => rubydebug 
    }
  }
}