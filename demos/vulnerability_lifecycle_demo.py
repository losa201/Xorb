#!/usr/bin/env python3
"""
XORB 2.0 Vulnerability Lifecycle Management Demo
Demonstrates automated vulnerability discovery, triage, and remediation workflows
"""

import asyncio
import random

# Import XORB components
import sys

sys.path.insert(0, '/root/Xorb')

from xorb_core.vulnerabilities.vulnerability_lifecycle_manager import (
    Vulnerability,
    VulnerabilityLifecycleManager,
    VulnerabilitySeverity,
    VulnerabilityState,
)


class VulnerabilityLifecycleDemo:
    """Comprehensive vulnerability management demonstration"""

    def __init__(self):
        self.manager = VulnerabilityLifecycleManager()
        self.demo_vulnerabilities = []

    async def setup_demo(self):
        """Set up demo environment with sample vulnerabilities"""
        print("🔧 Setting up XORB Vulnerability Lifecycle Demo...")

        # Create sample vulnerabilities
        sample_vulns = [
            {
                "title": "SQL Injection in Login Form",
                "description": "Unauthenticated SQL injection allowing database access",
                "severity": VulnerabilitySeverity.CRITICAL,
                "cve_id": "CVE-2024-1234",
                "affected_asset": "web-app-01.example.com",
                "discovery_source": "DAST Scanner",
                "technical_details": "Parameter 'username' vulnerable to SQL injection"
            },
            {
                "title": "Outdated SSL/TLS Configuration",
                "description": "Server supports deprecated TLS 1.0 protocol",
                "severity": VulnerabilitySeverity.MEDIUM,
                "cve_id": "CVE-2024-5678",
                "affected_asset": "api.example.com",
                "discovery_source": "SSL Scanner",
                "technical_details": "TLS 1.0 and weak ciphers enabled"
            },
            {
                "title": "Missing Security Headers",
                "description": "Web application missing critical security headers",
                "severity": VulnerabilitySeverity.LOW,
                "cve_id": None,
                "affected_asset": "blog.example.com",
                "discovery_source": "Header Scanner",
                "technical_details": "Missing X-Frame-Options, CSP headers"
            },
            {
                "title": "Privilege Escalation via SUID Binary",
                "description": "Custom SUID binary allows local privilege escalation",
                "severity": VulnerabilitySeverity.HIGH,
                "cve_id": "CVE-2024-9999",
                "affected_asset": "server-01.internal",
                "discovery_source": "Host Scanner",
                "technical_details": "Custom binary /usr/local/bin/helper has SUID bit set"
            }
        ]

        # Create vulnerability objects
        for vuln_data in sample_vulns:
            vulnerability = Vulnerability(
                title=vuln_data["title"],
                description=vuln_data["description"],
                severity=vuln_data["severity"],
                cve_id=vuln_data["cve_id"],
                target_name=vuln_data["affected_asset"],
                location=vuln_data["technical_details"]
            )

            self.demo_vulnerabilities.append(vulnerability)
            await self.manager.add_vulnerability(vulnerability)

        print(f"✅ Created {len(self.demo_vulnerabilities)} sample vulnerabilities")

    async def demonstrate_automated_triage(self):
        """Demonstrate automated vulnerability triage"""
        print("\n🤖 Demonstrating Automated Vulnerability Triage...")

        for vuln in self.demo_vulnerabilities:
            print(f"\n📋 Processing: {vuln.title}")
            print(f"   Severity: {vuln.severity.value}")
            print(f"   Asset: {vuln.target_name}")

            # Simulate automated triage decision
            await self.manager.update_vulnerability_state(vuln.vuln_id, VulnerabilityState.TRIAGED)

            # Get updated state
            updated_vuln = self.manager.get_vulnerability(vuln.vuln_id)
            if updated_vuln:
                print(f"   ✅ Triaged - State: {updated_vuln.state.value}")
                sla_deadline = getattr(updated_vuln, 'sla_deadline', 'Not set')
                print(f"   📅 SLA Deadline: {sla_deadline}")

            await asyncio.sleep(1)  # Simulate processing time

    async def demonstrate_remediation_workflow(self):
        """Demonstrate automated remediation workflows"""
        print("\n🔧 Demonstrating Automated Remediation Workflows...")

        # Find a high/critical severity vulnerability
        critical_vuln = next(
            (v for v in self.demo_vulnerabilities if v.severity in [
                VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH
            ]), None
        )

        if critical_vuln:
            print(f"\n🚨 Initiating remediation for: {critical_vuln.title}")

            # Start remediation - simulate remediation planning
            print("   📋 Creating remediation plan...")
            await asyncio.sleep(1)

            # Mock remediation plan
            remediation_plan = {
                "plan_type": "Automated SQL Injection Fix",
                "estimated_time": 2,
                "success_probability": 0.95
            }
            print(f"   📋 Remediation Plan: {remediation_plan['plan_type']}")
            print(f"   ⏱️  Estimated Time: {remediation_plan['estimated_time']} hours")
            print(f"   🎯 Success Rate: {remediation_plan['success_probability'] * 100:.1f}%")

            # Execute remediation
            print("   🔄 Executing automated remediation...")
            await asyncio.sleep(3)  # Simulate remediation time

            # Simulate successful remediation
            success = True
            if success:
                print("   ✅ Remediation completed successfully!")

                # Update vulnerability state to resolved
                await self.manager.update_vulnerability_state(critical_vuln.vuln_id, VulnerabilityState.RESOLVED)

                # Verify remediation
                updated_vuln = self.manager.get_vulnerability(critical_vuln.vuln_id)
                if updated_vuln and updated_vuln.state == VulnerabilityState.RESOLVED:
                    print("   🎯 Vulnerability verified as resolved")
            else:
                print("   ❌ Remediation failed - escalating to security team")

    async def demonstrate_compliance_reporting(self):
        """Demonstrate compliance and SLA reporting"""
        print("\n📊 Demonstrating Compliance & SLA Reporting...")

        # Get vulnerability statistics (simulated)
        total_vulns = len(self.demo_vulnerabilities)
        critical_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL)
        high_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.HIGH)
        medium_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM)
        low_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.LOW)

        print("\n📈 Vulnerability Statistics:")
        print(f"   Total Vulnerabilities: {total_vulns}")
        print(f"   Critical: {critical_count}")
        print(f"   High: {high_count}")
        print(f"   Medium: {medium_count}")
        print(f"   Low: {low_count}")

        print("\n🎯 SLA Compliance:")
        print(f"   Within SLA: {total_vulns - 1}")
        print("   SLA Breached: 1")
        print(f"   Compliance Rate: {((total_vulns - 1) / total_vulns) * 100:.1f}%")

        # Generate compliance report (simulated)
        report = {
            "period": "2024-12-27 to 2025-01-27",
            "summary": {
                "total_vulnerabilities": total_vulns,
                "resolved": total_vulns - 1,
                "resolution_rate": (total_vulns - 1) / total_vulns
            },
            "metrics": {
                "mttr": 24.5
            }
        }

        print("\n📋 Monthly Compliance Report:")
        print(f"   Report Period: {report['period']}")
        print(f"   Total Issues: {report['summary']['total_vulnerabilities']}")
        print(f"   Resolved: {report['summary']['resolved']}")
        print(f"   Resolution Rate: {report['summary']['resolution_rate'] * 100:.1f}%")
        print(f"   Mean Time to Resolution: {report['metrics']['mttr']:.1f} hours")

    async def demonstrate_threat_correlation(self):
        """Demonstrate threat intelligence correlation"""
        print("\n🕵️ Demonstrating Threat Intelligence Correlation...")

        for vuln in self.demo_vulnerabilities:
            if vuln.cve_id:
                print(f"\n🔍 Analyzing threat context for {vuln.cve_id}...")

                # Simulate threat intelligence lookup
                print("   🔄 Querying threat intelligence feeds...")
                await asyncio.sleep(1)

                # Mock threat intelligence data
                threat_context = {
                    "cvss_score": random.uniform(7.0, 10.0),
                    "exploitation_likelihood": "High",
                    "active_exploits": True,
                    "risk_score": random.randint(75, 95)
                }

                if threat_context:
                    print(f"   🎯 CVSS Score: {threat_context.get('cvss_score', 'N/A')}")
                    print(f"   🌍 Exploitation Likelihood: {threat_context.get('exploitation_likelihood', 'Unknown')}")
                    print(f"   🔥 Active Exploits: {'Yes' if threat_context.get('active_exploits') else 'No'}")
                    print(f"   📊 Risk Score: {threat_context.get('risk_score', 0)}/100")

                await asyncio.sleep(1)

    async def run_complete_demo(self):
        """Run the complete vulnerability lifecycle demonstration"""
        print("🚀 Starting XORB Vulnerability Lifecycle Management Demo")
        print("=" * 60)

        try:
            # Setup
            await self.setup_demo()

            # Run demonstration scenarios
            await self.demonstrate_automated_triage()
            await self.demonstrate_remediation_workflow()
            await self.demonstrate_threat_correlation()
            await self.demonstrate_compliance_reporting()

            print("\n🎉 Vulnerability Lifecycle Demo Complete!")
            print("=" * 60)
            print("✅ Demonstrated capabilities:")
            print("   • Automated vulnerability discovery and ingestion")
            print("   • Intelligent triage and prioritization")
            print("   • Automated remediation workflows")
            print("   • SLA tracking and compliance reporting")
            print("   • Threat intelligence correlation")
            print("   • Executive-level reporting and metrics")

        except Exception as e:
            print(f"❌ Demo failed: {e}")
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    demo = VulnerabilityLifecycleDemo()
    asyncio.run(demo.run_complete_demo())
