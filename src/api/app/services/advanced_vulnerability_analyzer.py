"""
Advanced vulnerability analysis service with ML-powered risk assessment
Provides sophisticated vulnerability correlation, prioritization, and impact analysis
"""

import asyncio
import logging
import json
import re
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, asdict
from enum import Enum
from datetime import datetime, timedelta
from uuid import uuid4
import hashlib

# Optional ML dependencies with graceful fallback
try:
    import numpy as np
    from sklearn.cluster import DBSCAN
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity
    ML_AVAILABLE = True
except ImportError:
    ML_AVAILABLE = False
    np = None

from .base_service import SecurityService, ServiceType
from ..domain.tenant_entities import SecurityFinding, ScanResult


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class AttackVector(Enum):
    """CVSS Attack Vector"""
    NETWORK = "network"
    ADJACENT = "adjacent"
    LOCAL = "local"
    PHYSICAL = "physical"


class ExploitAvailability(Enum):
    """Exploit availability status"""
    PUBLIC = "public"
    PROOF_OF_CONCEPT = "proof_of_concept"
    FUNCTIONAL = "functional"
    HIGH = "high"
    NONE = "none"


@dataclass
class VulnerabilityMetrics:
    """Detailed vulnerability metrics"""
    cvss_base_score: float
    cvss_temporal_score: float
    cvss_environmental_score: float
    attack_vector: AttackVector
    attack_complexity: str
    privileges_required: str
    user_interaction: str
    scope: str
    confidentiality_impact: str
    integrity_impact: str
    availability_impact: str
    exploit_availability: ExploitAvailability
    remediation_level: str
    report_confidence: str


@dataclass
class ThreatContext:
    """Threat intelligence context for vulnerability"""
    threat_actors: List[str]
    campaigns: List[str]
    malware_families: List[str]
    techniques: List[str]  # MITRE ATT&CK
    industry_targeting: List[str]
    geographic_targeting: List[str]
    first_seen: datetime
    last_seen: datetime
    trending_score: float


@dataclass
class BusinessImpact:
    """Business impact assessment"""
    confidentiality_risk: float
    integrity_risk: float
    availability_risk: float
    financial_impact: float
    compliance_impact: float
    reputation_impact: float
    operational_impact: float
    recovery_time_objective: int  # hours
    recovery_point_objective: int  # hours


@dataclass
class EnhancedVulnerability:
    """Enhanced vulnerability with comprehensive analysis"""
    id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    affected_component: str
    affected_service: str
    port: Optional[int]
    protocol: Optional[str]

    # Technical details
    metrics: VulnerabilityMetrics
    proof_of_concept: Optional[str]
    exploitation_requirements: List[str]

    # Threat intelligence
    threat_context: Optional[ThreatContext]

    # Business context
    business_impact: BusinessImpact

    # Remediation
    remediation_steps: List[str]
    remediation_complexity: str
    remediation_time_estimate: int  # hours
    temporary_mitigations: List[str]

    # Analysis metadata
    confidence_score: float
    risk_score: float
    priority_score: float
    false_positive_probability: float

    # Correlation
    related_vulnerabilities: List[str]
    attack_chain_position: Optional[str]

    created_at: datetime
    updated_at: datetime


class AdvancedVulnerabilityAnalyzer(SecurityService):
    """Advanced vulnerability analysis with ML-powered insights"""

    def __init__(self, **kwargs):
        super().__init__(service_type=ServiceType.SECURITY, **kwargs)
        self.logger = logging.getLogger(__name__)

        # Vulnerability database
        self._vulnerability_db: Dict[str, EnhancedVulnerability] = {}

        # ML models (if available)
        self._vectorizer = None
        self._clustering_model = None

        # Threat intelligence feeds
        self._threat_feeds = {
            "exploit_db": "https://exploit-db.com/",
            "metasploit": "https://rapid7.com/db/",
            "cve_details": "https://cvedetails.com/",
            "nvd": "https://nvd.nist.gov/"
        }

        # MITRE ATT&CK mapping
        self._attack_techniques = self._load_attack_techniques()

        # Industry-specific impact factors
        self._industry_factors = {
            "financial": {"confidentiality": 1.5, "integrity": 1.3, "availability": 1.2},
            "healthcare": {"confidentiality": 1.4, "integrity": 1.5, "availability": 1.3},
            "government": {"confidentiality": 1.6, "integrity": 1.4, "availability": 1.1},
            "critical_infrastructure": {"confidentiality": 1.2, "integrity": 1.6, "availability": 1.5},
            "retail": {"confidentiality": 1.3, "integrity": 1.2, "availability": 1.4},
            "technology": {"confidentiality": 1.4, "integrity": 1.3, "availability": 1.2}
        }

        # Initialize ML components if available
        if ML_AVAILABLE:
            self._initialize_ml_models()

    async def analyze_vulnerabilities(
        self,
        scan_results: List[SecurityFinding],
        target_context: Dict[str, Any] = None
    ) -> List[EnhancedVulnerability]:
        """Analyze vulnerabilities with advanced correlation and prioritization"""
        try:
            enhanced_vulnerabilities = []

            for finding in scan_results:
                enhanced = await self._enhance_vulnerability(finding, target_context)
                enhanced_vulnerabilities.append(enhanced)

            # Perform correlation analysis
            await self._correlate_vulnerabilities(enhanced_vulnerabilities)

            # Calculate attack chains
            await self._analyze_attack_chains(enhanced_vulnerabilities)

            # Prioritize vulnerabilities
            await self._prioritize_vulnerabilities(enhanced_vulnerabilities, target_context)

            # Update vulnerability database
            for vuln in enhanced_vulnerabilities:
                self._vulnerability_db[vuln.id] = vuln

            self.logger.info(f"Analyzed {len(enhanced_vulnerabilities)} vulnerabilities")
            return enhanced_vulnerabilities

        except Exception as e:
            self.logger.error(f"Error analyzing vulnerabilities: {str(e)}")
            raise

    async def _enhance_vulnerability(
        self,
        finding: SecurityFinding,
        target_context: Dict[str, Any] = None
    ) -> EnhancedVulnerability:
        """Enhance basic vulnerability finding with detailed analysis"""

        # Extract CVE if present
        cve_id = self._extract_cve(finding.description)

        # Calculate metrics
        metrics = await self._calculate_vulnerability_metrics(finding, cve_id)

        # Get threat intelligence context
        threat_context = await self._get_threat_context(cve_id, finding)

        # Assess business impact
        business_impact = await self._assess_business_impact(
            finding, metrics, target_context
        )

        # Generate remediation guidance
        remediation_steps = await self._generate_remediation_steps(finding, cve_id)

        # Calculate risk and priority scores
        risk_score = self._calculate_risk_score(metrics, threat_context, business_impact)
        priority_score = self._calculate_priority_score(risk_score, metrics, threat_context)

        # Assess false positive probability
        fp_probability = self._assess_false_positive_probability(finding)

        enhanced = EnhancedVulnerability(
            id=str(uuid4()),
            cve_id=cve_id,
            title=finding.title or "Unknown Vulnerability",
            description=finding.description,
            severity=VulnerabilitySeverity(finding.severity.lower()),
            affected_component=finding.component or "Unknown",
            affected_service=finding.service or "Unknown",
            port=finding.port,
            protocol=getattr(finding, 'protocol', None),

            metrics=metrics,
            proof_of_concept=await self._get_proof_of_concept(cve_id),
            exploitation_requirements=self._get_exploitation_requirements(finding),

            threat_context=threat_context,
            business_impact=business_impact,

            remediation_steps=remediation_steps,
            remediation_complexity=self._assess_remediation_complexity(finding),
            remediation_time_estimate=self._estimate_remediation_time(finding),
            temporary_mitigations=self._get_temporary_mitigations(finding),

            confidence_score=finding.confidence or 0.8,
            risk_score=risk_score,
            priority_score=priority_score,
            false_positive_probability=fp_probability,

            related_vulnerabilities=[],
            attack_chain_position=None,

            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )

        return enhanced

    async def _calculate_vulnerability_metrics(
        self,
        finding: SecurityFinding,
        cve_id: Optional[str]
    ) -> VulnerabilityMetrics:
        """Calculate detailed vulnerability metrics"""

        # Default CVSS scores
        base_score = self._severity_to_cvss(finding.severity)

        # Enhanced scores if CVE is available
        if cve_id:
            # In production, fetch from NVD API
            pass

        # Determine attack vector
        attack_vector = AttackVector.NETWORK
        if finding.port and finding.port < 1024:
            attack_vector = AttackVector.NETWORK
        elif finding.service and "local" in finding.service.lower():
            attack_vector = AttackVector.LOCAL

        # Assess exploit availability
        exploit_availability = ExploitAvailability.NONE
        if cve_id:
            exploit_availability = await self._check_exploit_availability(cve_id)

        return VulnerabilityMetrics(
            cvss_base_score=base_score,
            cvss_temporal_score=base_score * 0.9,  # Assume some temporal decay
            cvss_environmental_score=base_score * 1.1,  # Assume slightly higher in environment
            attack_vector=attack_vector,
            attack_complexity="low" if base_score > 7.0 else "high",
            privileges_required="none" if base_score > 8.0 else "low",
            user_interaction="none" if "remote" in finding.description.lower() else "required",
            scope="unchanged",
            confidentiality_impact="high" if base_score > 7.0 else "low",
            integrity_impact="high" if base_score > 7.0 else "low",
            availability_impact="high" if base_score > 7.0 else "low",
            exploit_availability=exploit_availability,
            remediation_level="official_fix",
            report_confidence="confirmed"
        )

    async def _get_threat_context(
        self,
        cve_id: Optional[str],
        finding: SecurityFinding
    ) -> Optional[ThreatContext]:
        """Get threat intelligence context for vulnerability"""

        if not cve_id:
            return None

        # In production, integrate with threat intelligence feeds
        # For now, return simulated context

        return ThreatContext(
            threat_actors=["APT1", "Carbanak"] if finding.severity.lower() == "critical" else [],
            campaigns=["Operation Aurora"] if "web" in finding.description.lower() else [],
            malware_families=["Emotet", "TrickBot"] if "windows" in finding.description.lower() else [],
            techniques=self._map_to_attack_techniques(finding),
            industry_targeting=["financial", "healthcare"],
            geographic_targeting=["global"],
            first_seen=datetime.utcnow() - timedelta(days=30),
            last_seen=datetime.utcnow() - timedelta(days=1),
            trending_score=0.7 if finding.severity.lower() in ["critical", "high"] else 0.3
        )

    async def _assess_business_impact(
        self,
        finding: SecurityFinding,
        metrics: VulnerabilityMetrics,
        target_context: Dict[str, Any] = None
    ) -> BusinessImpact:
        """Assess business impact of vulnerability"""

        # Base impact from CVSS
        base_conf = 0.3 if metrics.confidentiality_impact == "low" else 0.7
        base_int = 0.3 if metrics.integrity_impact == "low" else 0.7
        base_avail = 0.3 if metrics.availability_impact == "low" else 0.7

        # Industry-specific multipliers
        industry = target_context.get("industry", "technology") if target_context else "technology"
        factors = self._industry_factors.get(industry, {"confidentiality": 1.0, "integrity": 1.0, "availability": 1.0})

        # Asset criticality
        asset_criticality = target_context.get("asset_criticality", 1.0) if target_context else 1.0

        return BusinessImpact(
            confidentiality_risk=base_conf * factors["confidentiality"] * asset_criticality,
            integrity_risk=base_int * factors["integrity"] * asset_criticality,
            availability_risk=base_avail * factors["availability"] * asset_criticality,
            financial_impact=metrics.cvss_base_score * 10000,  # Simplified calculation
            compliance_impact=0.8 if industry in ["financial", "healthcare"] else 0.5,
            reputation_impact=0.9 if metrics.cvss_base_score > 8.0 else 0.5,
            operational_impact=base_avail * factors["availability"],
            recovery_time_objective=4 if metrics.cvss_base_score > 8.0 else 24,
            recovery_point_objective=1 if metrics.cvss_base_score > 8.0 else 8
        )

    async def _generate_remediation_steps(
        self,
        finding: SecurityFinding,
        cve_id: Optional[str]
    ) -> List[str]:
        """Generate specific remediation steps"""

        steps = []

        # Generic steps based on vulnerability type
        if "sql injection" in finding.description.lower():
            steps.extend([
                "Implement parameterized queries/prepared statements",
                "Validate and sanitize all user inputs",
                "Apply principle of least privilege to database accounts",
                "Enable SQL injection detection in WAF",
                "Conduct code review of affected modules"
            ])
        elif "xss" in finding.description.lower():
            steps.extend([
                "Implement output encoding for all user-controlled data",
                "Use Content Security Policy (CSP) headers",
                "Validate and sanitize input on both client and server side",
                "Update web application framework to latest version",
                "Enable XSS protection in web browser"
            ])
        elif "buffer overflow" in finding.description.lower():
            steps.extend([
                "Apply vendor security patches immediately",
                "Enable ASLR and DEP/NX bit protection",
                "Use safe string handling functions",
                "Implement stack canaries",
                "Conduct thorough code audit"
            ])
        elif "default credentials" in finding.description.lower():
            steps.extend([
                "Change all default usernames and passwords immediately",
                "Implement strong password policy",
                "Enable multi-factor authentication",
                "Regular credential rotation",
                "Monitor for unauthorized access attempts"
            ])
        elif "ssl" in finding.description.lower() or "tls" in finding.description.lower():
            steps.extend([
                "Update to latest TLS version (1.3)",
                "Disable weak cipher suites",
                "Implement HSTS headers",
                "Use strong certificate validation",
                "Regular certificate renewal process"
            ])
        else:
            steps.extend([
                "Apply vendor security patches",
                "Update affected software to latest version",
                "Implement compensating controls",
                "Monitor for exploitation attempts",
                "Review and update security configuration"
            ])

        # Add CVE-specific remediation if available
        if cve_id:
            steps.append(f"Review CVE details: https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}")

        return steps

    async def _correlate_vulnerabilities(self, vulnerabilities: List[EnhancedVulnerability]):
        """Correlate vulnerabilities to identify attack patterns"""

        if not ML_AVAILABLE or len(vulnerabilities) < 2:
            return

        try:
            # Create feature vectors from vulnerability descriptions
            descriptions = [vuln.description for vuln in vulnerabilities]
            vectors = self._vectorizer.fit_transform(descriptions)

            # Calculate similarity matrix
            similarity_matrix = cosine_similarity(vectors)

            # Find highly correlated vulnerabilities (similarity > 0.7)
            for i, vuln1 in enumerate(vulnerabilities):
                related = []
                for j, vuln2 in enumerate(vulnerabilities):
                    if i != j and similarity_matrix[i][j] > 0.7:
                        related.append(vuln2.id)
                vuln1.related_vulnerabilities = related

        except Exception as e:
            self.logger.error(f"Error correlating vulnerabilities: {str(e)}")

    async def _analyze_attack_chains(self, vulnerabilities: List[EnhancedVulnerability]):
        """Analyze potential attack chains"""

        # Simple attack chain analysis based on vulnerability types
        recon_vulns = []
        initial_access = []
        privilege_esc = []
        lateral_movement = []

        for vuln in vulnerabilities:
            desc_lower = vuln.description.lower()

            if any(term in desc_lower for term in ["information disclosure", "banner", "version"]):
                recon_vulns.append(vuln)
                vuln.attack_chain_position = "reconnaissance"
            elif any(term in desc_lower for term in ["remote", "rce", "sql injection", "xss"]):
                initial_access.append(vuln)
                vuln.attack_chain_position = "initial_access"
            elif any(term in desc_lower for term in ["privilege", "escalation", "admin"]):
                privilege_esc.append(vuln)
                vuln.attack_chain_position = "privilege_escalation"
            elif any(term in desc_lower for term in ["lateral", "network", "smb", "rdp"]):
                lateral_movement.append(vuln)
                vuln.attack_chain_position = "lateral_movement"

    async def _prioritize_vulnerabilities(
        self,
        vulnerabilities: List[EnhancedVulnerability],
        target_context: Dict[str, Any] = None
    ):
        """Prioritize vulnerabilities based on comprehensive scoring"""

        # Sort by priority score (descending)
        vulnerabilities.sort(key=lambda v: v.priority_score, reverse=True)

        # Add priority ranking
        for i, vuln in enumerate(vulnerabilities):
            vuln.priority_rank = i + 1

    def _calculate_risk_score(
        self,
        metrics: VulnerabilityMetrics,
        threat_context: Optional[ThreatContext],
        business_impact: BusinessImpact
    ) -> float:
        """Calculate comprehensive risk score"""

        # Base score from CVSS
        base_score = metrics.cvss_base_score / 10.0

        # Threat intelligence multiplier
        threat_multiplier = 1.0
        if threat_context:
            if threat_context.threat_actors:
                threat_multiplier += 0.3
            if threat_context.campaigns:
                threat_multiplier += 0.2
            threat_multiplier += threat_context.trending_score * 0.2

        # Exploit availability multiplier
        exploit_multiplier = {
            ExploitAvailability.PUBLIC: 1.5,
            ExploitAvailability.FUNCTIONAL: 1.3,
            ExploitAvailability.PROOF_OF_CONCEPT: 1.1,
            ExploitAvailability.HIGH: 1.2,
            ExploitAvailability.NONE: 1.0
        }.get(metrics.exploit_availability, 1.0)

        # Business impact multiplier
        business_multiplier = (
            business_impact.confidentiality_risk +
            business_impact.integrity_risk +
            business_impact.availability_risk
        ) / 3.0

        # Final risk score
        risk_score = base_score * threat_multiplier * exploit_multiplier * business_multiplier

        return min(1.0, risk_score)  # Cap at 1.0

    def _calculate_priority_score(
        self,
        risk_score: float,
        metrics: VulnerabilityMetrics,
        threat_context: Optional[ThreatContext]
    ) -> float:
        """Calculate vulnerability priority score for remediation ordering"""

        # Start with risk score
        priority = risk_score

        # Boost based on attack vector
        if metrics.attack_vector == AttackVector.NETWORK:
            priority += 0.2
        elif metrics.attack_vector == AttackVector.ADJACENT:
            priority += 0.1

        # Boost if actively exploited
        if threat_context and threat_context.campaigns:
            priority += 0.3

        # Boost based on CVSS score
        if metrics.cvss_base_score >= 9.0:
            priority += 0.2
        elif metrics.cvss_base_score >= 7.0:
            priority += 0.1

        return min(1.0, priority)

    def _assess_false_positive_probability(self, finding: SecurityFinding) -> float:
        """Assess probability that finding is a false positive"""

        # Simple heuristic based on confidence and finding characteristics
        base_fp = 1.0 - (finding.confidence or 0.8)

        # Adjust based on vulnerability type
        if "information disclosure" in finding.description.lower():
            base_fp += 0.1  # Often false positives
        elif "sql injection" in finding.description.lower():
            base_fp -= 0.1  # Usually accurate

        return min(0.9, max(0.1, base_fp))

    def _extract_cve(self, description: str) -> Optional[str]:
        """Extract CVE identifier from description"""
        cve_pattern = r"CVE-\d{4}-\d{4,7}"
        match = re.search(cve_pattern, description, re.IGNORECASE)
        return match.group(0).upper() if match else None

    def _severity_to_cvss(self, severity: str) -> float:
        """Convert severity string to CVSS score"""
        severity_map = {
            "critical": 9.5,
            "high": 7.5,
            "medium": 5.5,
            "low": 3.5,
            "info": 1.0
        }
        return severity_map.get(severity.lower(), 5.0)

    async def _check_exploit_availability(self, cve_id: str) -> ExploitAvailability:
        """Check if public exploits are available"""
        # In production, check exploit databases
        # For now, return simulated result
        return ExploitAvailability.PROOF_OF_CONCEPT

    def _map_to_attack_techniques(self, finding: SecurityFinding) -> List[str]:
        """Map vulnerability to MITRE ATT&CK techniques"""
        techniques = []
        desc_lower = finding.description.lower()

        if "sql injection" in desc_lower:
            techniques.append("T1190")  # Exploit Public-Facing Application
        elif "xss" in desc_lower:
            techniques.append("T1190")  # Exploit Public-Facing Application
        elif "buffer overflow" in desc_lower:
            techniques.append("T1068")  # Exploitation for Privilege Escalation
        elif "default credentials" in desc_lower:
            techniques.append("T1078")  # Valid Accounts

        return techniques

    def _get_exploitation_requirements(self, finding: SecurityFinding) -> List[str]:
        """Get requirements for successful exploitation"""
        requirements = []
        desc_lower = finding.description.lower()

        if "authentication" in desc_lower:
            requirements.append("Valid user credentials")
        if "network access" in desc_lower:
            requirements.append("Network connectivity to target")
        if "local access" in desc_lower:
            requirements.append("Local access to target system")

        return requirements or ["Remote network access"]

    async def _get_proof_of_concept(self, cve_id: Optional[str]) -> Optional[str]:
        """Get proof of concept exploit if available"""
        if cve_id:
            return f"Check Exploit-DB for {cve_id} proof-of-concept exploits"
        return None

    def _assess_remediation_complexity(self, finding: SecurityFinding) -> str:
        """Assess complexity of remediation"""
        if "patch" in finding.description.lower():
            return "low"
        elif "configuration" in finding.description.lower():
            return "medium"
        else:
            return "high"

    def _estimate_remediation_time(self, finding: SecurityFinding) -> int:
        """Estimate remediation time in hours"""
        severity_time = {
            "critical": 4,
            "high": 8,
            "medium": 24,
            "low": 72,
            "info": 168
        }
        return severity_time.get(finding.severity.lower(), 24)

    def _get_temporary_mitigations(self, finding: SecurityFinding) -> List[str]:
        """Get temporary mitigation steps"""
        mitigations = []
        desc_lower = finding.description.lower()

        if "web" in desc_lower:
            mitigations.append("Enable WAF protection")
        if "network" in desc_lower:
            mitigations.append("Implement network segmentation")
        if "service" in desc_lower:
            mitigations.append("Disable non-essential services")

        return mitigations or ["Monitor for exploitation attempts"]

    def _initialize_ml_models(self):
        """Initialize ML models for vulnerability analysis"""
        if not ML_AVAILABLE:
            return

        try:
            # Initialize TF-IDF vectorizer for text analysis
            self._vectorizer = TfidfVectorizer(
                max_features=1000,
                stop_words='english',
                ngram_range=(1, 2)
            )

            # Initialize clustering model
            self._clustering_model = DBSCAN(eps=0.3, min_samples=2)

            self.logger.info("Initialized ML models for vulnerability analysis")

        except Exception as e:
            self.logger.error(f"Error initializing ML models: {str(e)}")
            self._vectorizer = None
            self._clustering_model = None

    def _load_attack_techniques(self) -> Dict[str, Dict[str, Any]]:
        """Load MITRE ATT&CK techniques mapping"""
        # Simplified mapping for demonstration
        return {
            "T1190": {
                "name": "Exploit Public-Facing Application",
                "description": "Adversaries may attempt to take advantage of a weakness in an Internet-facing computer or program using software, data, or commands in order to cause unintended or unanticipated behavior."
            },
            "T1068": {
                "name": "Exploitation for Privilege Escalation",
                "description": "Adversaries may exploit software vulnerabilities in an attempt to elevate privileges."
            },
            "T1078": {
                "name": "Valid Accounts",
                "description": "Adversaries may obtain and abuse credentials of existing accounts as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion."
            }
        }

    async def health_check(self) -> Dict[str, Any]:
        """Perform health check"""
        try:
            return {
                "status": "healthy",
                "ml_available": ML_AVAILABLE,
                "vulnerability_count": len(self._vulnerability_db),
                "threat_feeds": len(self._threat_feeds),
                "attack_techniques": len(self._attack_techniques),
                "industry_factors": len(self._industry_factors),
                "timestamp": str(datetime.utcnow().timestamp())
            }

        except Exception as e:
            self.logger.error(f"Vulnerability analyzer health check failed: {str(e)}")
            return {
                "status": "unhealthy",
                "error": str(e),
                "timestamp": str(datetime.utcnow().timestamp())
            }
