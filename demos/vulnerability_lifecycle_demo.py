#!/usr/bin/env python3
"""
XORB 2.0 Vulnerability Lifecycle Management Demo
Demonstrates automated vulnerability discovery, triage, and remediation workflows
"""

import asyncio
import json
import random
import time
from datetime import datetime, timedelta
from typing import Dict, List

# Import XORB components
import sys
sys.path.insert(0, '/root/Xorb')

from xorb_core.vulnerabilities.vulnerability_lifecycle_manager import (
    VulnerabilityLifecycleManager, Vulnerability, VulnerabilityState,
    VulnerabilitySeverity, AutomatedRemediationProvider
)

class VulnerabilityLifecycleDemo:
    """Comprehensive vulnerability management demonstration"""
    
    def __init__(self):
        self.manager = VulnerabilityLifecycleManager()
        self.demo_vulnerabilities = []
        
    async def setup_demo(self):
        """Set up demo environment with sample vulnerabilities"""
        print("ğŸ”§ Setting up XORB Vulnerability Lifecycle Demo...")
        
        # Create sample vulnerabilities
        sample_vulns = [
            {
                "title": "SQL Injection in Login Form",
                "description": "Unauthenticated SQL injection allowing database access",
                "severity": VulnerabilitySeverity.CRITICAL,
                "cve_id": "CVE-2024-1234",
                "affected_asset": "web-app-01.example.com",
                "discovery_source": "DAST Scanner",
                "technical_details": "Parameter 'username' vulnerable to SQL injection"
            },
            {
                "title": "Outdated SSL/TLS Configuration", 
                "description": "Server supports deprecated TLS 1.0 protocol",
                "severity": VulnerabilitySeverity.MEDIUM,
                "cve_id": "CVE-2024-5678",
                "affected_asset": "api.example.com",
                "discovery_source": "SSL Scanner",
                "technical_details": "TLS 1.0 and weak ciphers enabled"
            },
            {
                "title": "Missing Security Headers",
                "description": "Web application missing critical security headers",
                "severity": VulnerabilitySeverity.LOW,
                "cve_id": None,
                "affected_asset": "blog.example.com",
                "discovery_source": "Header Scanner",
                "technical_details": "Missing X-Frame-Options, CSP headers"
            },
            {
                "title": "Privilege Escalation via SUID Binary",
                "description": "Custom SUID binary allows local privilege escalation",
                "severity": VulnerabilitySeverity.HIGH,
                "cve_id": "CVE-2024-9999",
                "affected_asset": "server-01.internal",
                "discovery_source": "Host Scanner",
                "technical_details": "Custom binary /usr/local/bin/helper has SUID bit set"
            }
        ]
        
        # Create vulnerability objects
        for vuln_data in sample_vulns:
            vulnerability = Vulnerability(
                title=vuln_data["title"],
                description=vuln_data["description"],
                severity=vuln_data["severity"],
                cve_id=vuln_data["cve_id"],
                target_name=vuln_data["affected_asset"],
                location=vuln_data["technical_details"]
            )
            
            self.demo_vulnerabilities.append(vulnerability)
            await self.manager.add_vulnerability(vulnerability)
            
        print(f"âœ… Created {len(self.demo_vulnerabilities)} sample vulnerabilities")
        
    async def demonstrate_automated_triage(self):
        """Demonstrate automated vulnerability triage"""
        print("\nğŸ¤– Demonstrating Automated Vulnerability Triage...")
        
        for vuln in self.demo_vulnerabilities:
            print(f"\nğŸ“‹ Processing: {vuln.title}")
            print(f"   Severity: {vuln.severity.value}")
            print(f"   Asset: {vuln.target_name}")
            
            # Simulate automated triage decision  
            await self.manager.update_vulnerability_state(vuln.vuln_id, VulnerabilityState.TRIAGED)
            
            # Get updated state
            updated_vuln = self.manager.get_vulnerability(vuln.vuln_id)
            if updated_vuln:
                print(f"   âœ… Triaged - State: {updated_vuln.state.value}")
                sla_deadline = getattr(updated_vuln, 'sla_deadline', 'Not set')
                print(f"   ğŸ“… SLA Deadline: {sla_deadline}")
                
            await asyncio.sleep(1)  # Simulate processing time
            
    async def demonstrate_remediation_workflow(self):
        """Demonstrate automated remediation workflows"""
        print("\nğŸ”§ Demonstrating Automated Remediation Workflows...")
        
        # Find a high/critical severity vulnerability
        critical_vuln = next(
            (v for v in self.demo_vulnerabilities if v.severity in [
                VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH
            ]), None
        )
        
        if critical_vuln:
            print(f"\nğŸš¨ Initiating remediation for: {critical_vuln.title}")
            
            # Start remediation - simulate remediation planning
            print(f"   ğŸ“‹ Creating remediation plan...")
            await asyncio.sleep(1)
            
            # Mock remediation plan
            remediation_plan = {
                "plan_type": "Automated SQL Injection Fix",
                "estimated_time": 2,
                "success_probability": 0.95
            }
            print(f"   ğŸ“‹ Remediation Plan: {remediation_plan['plan_type']}")
            print(f"   â±ï¸  Estimated Time: {remediation_plan['estimated_time']} hours")
            print(f"   ğŸ¯ Success Rate: {remediation_plan['success_probability'] * 100:.1f}%")
            
            # Execute remediation
            print("   ğŸ”„ Executing automated remediation...")
            await asyncio.sleep(3)  # Simulate remediation time
            
            # Simulate successful remediation
            success = True
            if success:
                print("   âœ… Remediation completed successfully!")
                
                # Update vulnerability state to resolved
                await self.manager.update_vulnerability_state(critical_vuln.vuln_id, VulnerabilityState.RESOLVED)
                
                # Verify remediation
                updated_vuln = self.manager.get_vulnerability(critical_vuln.vuln_id)
                if updated_vuln and updated_vuln.state == VulnerabilityState.RESOLVED:
                    print("   ğŸ¯ Vulnerability verified as resolved")
            else:
                print("   âŒ Remediation failed - escalating to security team")
                    
    async def demonstrate_compliance_reporting(self):
        """Demonstrate compliance and SLA reporting"""
        print("\nğŸ“Š Demonstrating Compliance & SLA Reporting...")
        
        # Get vulnerability statistics (simulated)
        total_vulns = len(self.demo_vulnerabilities)
        critical_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL)
        high_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.HIGH)
        medium_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM)
        low_count = sum(1 for v in self.demo_vulnerabilities if v.severity == VulnerabilitySeverity.LOW)
        
        print("\nğŸ“ˆ Vulnerability Statistics:")
        print(f"   Total Vulnerabilities: {total_vulns}")
        print(f"   Critical: {critical_count}")
        print(f"   High: {high_count}")
        print(f"   Medium: {medium_count}")
        print(f"   Low: {low_count}")
        
        print("\nğŸ¯ SLA Compliance:")
        print(f"   Within SLA: {total_vulns - 1}")
        print(f"   SLA Breached: 1")
        print(f"   Compliance Rate: {((total_vulns - 1) / total_vulns) * 100:.1f}%")
        
        # Generate compliance report (simulated)
        report = {
            "period": "2024-12-27 to 2025-01-27",
            "summary": {
                "total_vulnerabilities": total_vulns,
                "resolved": total_vulns - 1,
                "resolution_rate": (total_vulns - 1) / total_vulns
            },
            "metrics": {
                "mttr": 24.5
            }
        }
        
        print(f"\nğŸ“‹ Monthly Compliance Report:")
        print(f"   Report Period: {report['period']}")
        print(f"   Total Issues: {report['summary']['total_vulnerabilities']}")
        print(f"   Resolved: {report['summary']['resolved']}")
        print(f"   Resolution Rate: {report['summary']['resolution_rate'] * 100:.1f}%")
        print(f"   Mean Time to Resolution: {report['metrics']['mttr']:.1f} hours")
        
    async def demonstrate_threat_correlation(self):
        """Demonstrate threat intelligence correlation"""
        print("\nğŸ•µï¸ Demonstrating Threat Intelligence Correlation...")
        
        for vuln in self.demo_vulnerabilities:
            if vuln.cve_id:
                print(f"\nğŸ” Analyzing threat context for {vuln.cve_id}...")
                
                # Simulate threat intelligence lookup
                print(f"   ğŸ”„ Querying threat intelligence feeds...")
                await asyncio.sleep(1)
                
                # Mock threat intelligence data
                threat_context = {
                    "cvss_score": random.uniform(7.0, 10.0),
                    "exploitation_likelihood": "High",
                    "active_exploits": True,
                    "risk_score": random.randint(75, 95)
                }
                
                if threat_context:
                    print(f"   ğŸ¯ CVSS Score: {threat_context.get('cvss_score', 'N/A')}")
                    print(f"   ğŸŒ Exploitation Likelihood: {threat_context.get('exploitation_likelihood', 'Unknown')}")
                    print(f"   ğŸ”¥ Active Exploits: {'Yes' if threat_context.get('active_exploits') else 'No'}")
                    print(f"   ğŸ“Š Risk Score: {threat_context.get('risk_score', 0)}/100")
                    
                await asyncio.sleep(1)
                
    async def run_complete_demo(self):
        """Run the complete vulnerability lifecycle demonstration"""
        print("ğŸš€ Starting XORB Vulnerability Lifecycle Management Demo")
        print("=" * 60)
        
        try:
            # Setup
            await self.setup_demo()
            
            # Run demonstration scenarios
            await self.demonstrate_automated_triage()
            await self.demonstrate_remediation_workflow()
            await self.demonstrate_threat_correlation()
            await self.demonstrate_compliance_reporting()
            
            print("\nğŸ‰ Vulnerability Lifecycle Demo Complete!")
            print("=" * 60)
            print("âœ… Demonstrated capabilities:")
            print("   â€¢ Automated vulnerability discovery and ingestion")
            print("   â€¢ Intelligent triage and prioritization")
            print("   â€¢ Automated remediation workflows")
            print("   â€¢ SLA tracking and compliance reporting")
            print("   â€¢ Threat intelligence correlation")
            print("   â€¢ Executive-level reporting and metrics")
            
        except Exception as e:
            print(f"âŒ Demo failed: {e}")
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    demo = VulnerabilityLifecycleDemo()
    asyncio.run(demo.run_complete_demo())