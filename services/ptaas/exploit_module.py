"""
Exploit Module for XORB PTaaS

This module implements safe exploitation simulation capabilities for the PTaaS service.
"""
import asyncio
import logging
import os
import re
import tempfile
from typing import Dict, List, Optional, Any, Union

import aiohttp
from tenacity import retry, stop_after_attempt, wait_exponential

from xorlib import XORLibError, SecurityContext, AuditLogger
from xorlib.config import XorbConfig
from xorlib.models import ExploitationResult, ScanTarget
from xorlib.utils import validate_target, sanitize_input, generate_nonce

logger = logging.getLogger(__name__)

class SafeExploitEngine:
    """Engine for safe exploitation simulation with security controls."""

    def __init__(self, config: Optional[XorbConfig] = None):
        """Initialize the exploit engine with configuration.

        Args:
            config: Optional configuration object. If not provided, uses default configuration.

        Raises:
            XORLibError: If initialization fails
        """
        try:
            self.config = config or XorbConfig()
            self.security_context = SecurityContext()
            self.audit_logger = AuditLogger()
            self.xorlib = XORLib()

            # Initialize exploit modules
            self.exploit_modules = self._load_exploit_modules()

            # Initialize security controls
            self.sandbox_dir = self._setup_sandbox_environment()

            logger.info("Exploit engine initialized successfully")

        except Exception as e:
            logger.error(f"Failed to initialize exploit engine: {str(e)}")
            raise XORLibError(f"Exploit engine initialization failed: {str(e)}") from e

    def _load_exploit_modules(self) -> Dict[str, Any]:
        """Load and initialize exploit modules."""
        modules_path = self.config.get('exploit.modules_path', 'exploit_modules')
        modules = {}

        try:
            if not os.path.exists(modules_path):
                logger.warning(f"Exploit modules directory not found: {modules_path}")
                return modules

            for module_file in os.listdir(modules_path):
                if module_file.endswith('.py') and not module_file.startswith('_'):
                    module_name = module_file[:-3]
                    try:
                        module = self.xorlib.load_exploit_module(
                            os.path.join(modules_path, module_file)
                        )
                        modules[module_name] = module
                        logger.debug(f"Loaded exploit module: {module_name}")
                    except Exception as e:
                        logger.warning(f"Failed to load exploit module {module_name}: {str(e)}")

            return modules

        except Exception as e:
            logger.error(f"Error loading exploit modules: {str(e)}")
            return modules

    def _setup_sandbox_environment(self) -> str:
        """Set up a sandboxed environment for exploit execution."""
        sandbox_base = self.config.get('exploit.sandbox_base', '/tmp/ptaas_sandbox')

        # Create base directory if it doesn't exist
        os.makedirs(sandbox_base, exist_ok=True)

        # Create a unique sandbox directory for this instance
        sandbox_dir = os.path.join(sandbox_base, generate_nonce(16))
        os.makedirs(sandbox_dir, exist_ok=True)

        logger.debug(f"Sandbox environment created at: {sandbox_dir}")
        return sandbox_dir

    async def execute_exploit(self,
                            module_name: str,
                            target: Union[str, ScanTarget],
                            options: Optional[Dict[str, Any]] = None) -> ExploitationResult:
        """Execute a specific exploit module against a target.

        Args:
            module_name: Name of the exploit module to use
            target: Target system information (IP, domain, or ScanTarget object)
            options: Optional dictionary of exploit-specific options

        Returns:
            ExploitationResult object containing the results

        Raises:
            XORLibError: If exploit execution fails
        """
        logger.info(f"Executing exploit: {module_name} against {target}")

        try:
            # Convert target to ScanTarget if needed
            if isinstance(target, str):
                target = ScanTarget(target=target)

            # Validate target format
            if not validate_target(target.target):
                raise XORLibError(f"Invalid target format: {target.target}")

            # Sanitize inputs
            sanitized_target = sanitize_input(target.target)
            sanitized_module = sanitize_input(module_name)

            # Check if module exists
            if sanitized_module not in self.exploit_modules:
                raise XORLibError(f"Exploit module not found: {sanitized_module}")

            # Get the exploit module
            exploit_module = self.exploit_modules[sanitized_module]

            # Prepare exploit configuration
            config = {
                'target': sanitized_target,
                'module': sanitized_module,
                'options': options or {},
                'sandbox_dir': self.sandbox_dir,
                'timeout': self.config.get('exploit.timeout', 30),
                'verbose': self.config.get('exploit.verbose', False),
                'security_context': self.security_context
            }

            # Execute the exploit in a sandboxed environment
            result = await self._execute_sandboxed_exploit(exploit_module, config)

            # Log audit event
            self.audit_logger.log_event(
                event_type='exploit_executed',
                data={
                    'module': sanitized_module,
                    'target': sanitized_target,
                    'success': result.success,
                    'access_level': result.access_level
                }
            )

            logger.info(f"Exploit {module_name} completed: {'Success' if result.success else 'Failed'}")
            return result

        except Exception as e:
            logger.error(f"Exploit execution failed: {str(e)}")
            # Log error event
            self.audit_logger.log_event(
                event_type='exploit_failed',
                data={
                    'module': module_name,
                    'target': str(target),
                    'error': str(e)
                }
            )
            raise XORLibError(f"Exploit execution failed: {str(e)}") from e

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, max=10))
    async def _execute_sandboxed_exploit(self, module: Any, config: Dict[str, Any]) -> ExploitationResult:
        """Execute an exploit in a sandboxed environment with retry logic.

        Args:
            module: The exploit module to execute
            config: Configuration dictionary for the exploit

        Returns:
            ExploitationResult object containing the results

        Raises:
            XORLibError: If the sandboxed execution fails
        """
        try:
            # Create a temporary directory for this exploit execution
            with tempfile.TemporaryDirectory(dir=self.sandbox_dir) as temp_dir:
                # Set up the execution environment
                execution_env = self._prepare_execution_environment(temp_dir, config)

                # Execute the exploit
                result = await module.exploit(execution_env)

                # Process and validate the result
                processed_result = self._process_exploit_result(result)

                return processed_result

        except Exception as e:
            logger.error(f"Sandboxed exploit execution failed: {str(e)}")
            raise

    def _prepare_execution_environment(self, temp_dir: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare the execution environment for the exploit.

        Args:
            temp_dir: Temporary directory for this execution
            config: Configuration dictionary for the exploit

        Returns:
            Dictionary containing the prepared execution environment
        """
        # Create a copy of the config
        execution_env = config.copy()

        # Add execution-specific paths
        execution_env['temp_dir'] = temp_dir
        execution_env['working_dir'] = os.path.join(temp_dir, 'work')
        execution_env['output_dir'] = os.path.join(temp_dir, 'output')
        execution_env['log_dir'] = os.path.join(temp_dir, 'logs')

        # Create necessary directories
        os.makedirs(execution_env['working_dir'], exist_ok=True)
        os.makedirs(execution_env['output_dir'], exist_ok=True)
        os.makedirs(execution_env['log_dir'], exist_ok=True)

        # Add security context
        execution_env['security_context'] = self.security_context.create_child_context(
            sandbox_dir=temp_dir,
            restricted=True,
            timeout=config.get('timeout', 30),
            memory_limit=self.config.get('exploit.memory_limit', '512M')
        )

        return execution_env

    def _process_exploit_result(self, result: Dict[str, Any]) -> ExploitationResult:
        """Process and validate the exploit result.

        Args:
            result: Dictionary containing raw exploit results

        Returns:
            ExploitationResult object with processed results
        """
        # Validate required fields
        required_fields = ['success', 'target', 'module']
        for field in required_fields:
            if field not in result:
                raise XORLibError(f"Missing required field in exploit result: {field}")

        # Create ExploitationResult object
        exploitation_result = ExploitationResult(
            cve=result.get('cve'),
            success=result['success'],
            target=result['target'],
            access_level=result.get('access_level', 'none'),
            output=result.get('output', ''),
            session_id=result.get('session_id') if result.get('session_id') else None,
            timestamp=result.get('timestamp', self._get_current_timestamp())
        )

        # Sanitize output
        if exploitation_result.output:
            exploitation_result.output = sanitize_input(exploitation_result.output)

        return exploitation_result

    def _get_current_timestamp(self) -> str:
        """Get current timestamp in ISO format."""
        from datetime import datetime
        return datetime.utcnow().isoformat()

    async def cleanup(self) -> None:
        """Clean up the exploit engine and sandbox environment."""
        logger.info("Cleaning up exploit engine")

        try:
            # Clean up sandbox directory
            if os.path.exists(self.sandbox_dir):
                # Remove all files in the sandbox directory
                for item in os.listdir(self.sandbox_dir):
                    item_path = os.path.join(self.sandbox_dir, item)
                    if os.path.isdir(item_path):
                        try:
                            os.rmdir(item_path)  # Will fail if directory is not empty
                        except OSError:
                            logger.warning(f"Failed to remove sandbox directory: {item_path} (not empty)")

            logger.info("Exploit engine cleanup completed")

        except Exception as e:
            logger.error(f"Exploit engine cleanup failed: {str(e)}")

# Example usage
if __name__ == "__main__":
    import asyncio

    async def main():
        # Initialize exploit engine
        engine = SafeExploitEngine()

        try:
            # Execute an exploit
            result = await engine.execute_exploit(
                module_name="eternalblue",
                target="192.168.1.100",
                options={
                    'payload': 'reverse_shell',
                    'lhost': '192.168.1.1',
                    'lport': 4444
                }
            )

            # Print results
            print(f"Exploit Success: {result.success}")
            print(f"Access Level: {result.access_level}")
            print(f"Output: {result.output[:200]}...")  # Print first 200 chars

        finally:
            # Clean up
            await engine.cleanup()

    asyncio.run(main())
