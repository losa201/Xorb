from dataclasses import dataclass

#!/usr/bin/env python3
"""
Vulnerability Lifecycle Management Demonstration

This script demonstrates the comprehensive vulnerability lifecycle management
capabilities including discovery, automated triage, remediation workflow,
and lifecycle tracking.
"""

import asyncio
import sys
import time
from pathlib import Path

# Add the xorb_core to Python path
sys.path.insert(0, str(Path(__file__).parent.parent))

import structlog

from xorb_core.vulnerabilities import (
    Vulnerability,
    VulnerabilityCategory,
    VulnerabilitySeverity,
    VulnerabilityState,
    vulnerability_manager,
)

logger = structlog.get_logger(__name__)


@dataclass
class VulnerabilityLifecycleDemo:
    """Comprehensive vulnerability lifecycle demonstration."""

    def __init__(self) -> None:
        self.demo_vulnerabilities = []

    async def run_demo(self) -> None:
        """Run the complete vulnerability lifecycle demonstration."""
        print("üîç VULNERABILITY LIFECYCLE MANAGEMENT DEMONSTRATION")
        print("=" * 65)
        print("This demo showcases comprehensive vulnerability management:")
        print("‚Ä¢ Vulnerability discovery and classification")
        print("‚Ä¢ Automated triage and workflow automation")
        print("‚Ä¢ Remediation step generation and execution")
        print("‚Ä¢ SLA tracking and violation management")
        print("‚Ä¢ Lifecycle state management and reporting")
        print("=" * 65)

        try:
            # Start the vulnerability management system
            await self._initialize_system()

            # Run demonstration scenarios
            await self._demo_vulnerability_discovery()
            await self._demo_automated_triage()
            await self._demo_remediation_workflow()
            await self._demo_sla_management()
            await self._demo_lifecycle_tracking()
            await self._demo_reporting()

            # Generate final report
            await self._generate_summary_report()

        except Exception as e:
            print(f"‚ùå Demo failed: {e}")
            import traceback
            traceback.print_exc()
        finally:
            await self._cleanup_system()

    async def _initialize_system(self) -> None:
        """Initialize the vulnerability management system."""
        print("\nüöÄ Initializing Vulnerability Management System...")

        # Start the vulnerability manager (in demo mode - no background loops)
        vulnerability_manager.running = True

        print("‚úÖ Vulnerability management system initialized")

    async def _demo_vulnerability_discovery(self) -> None:
        """Demonstrate vulnerability discovery and classification."""
        print("\nüîç VULNERABILITY DISCOVERY DEMONSTRATION")
        print("-" * 50)

        # Create sample vulnerabilities representing different scenarios
        sample_vulns = [
            {
                "title": "SQL Injection in User Login",
                "description": "User input not properly sanitized in login form allowing SQL injection",
                "severity": VulnerabilitySeverity.HIGH,
                "cvss_score": 8.1,
                "category": VulnerabilityCategory.INJECTION,
                "cwe_id": "CWE-89",
                "target_name": "WebApp Production",
                "location": "https://app.example.com/login",
                "business_impact": "high",
                "affected_users": 15000
            },
            {
                "title": "Weak SSL/TLS Configuration",
                "description": "Server supports weak TLS versions and cipher suites",
                "severity": VulnerabilitySeverity.MEDIUM,
                "cvss_score": 5.3,
                "category": VulnerabilityCategory.CRYPTOGRAPHIC,
                "cwe_id": "CWE-327",
                "target_name": "API Gateway",
                "location": "https://api.example.com",
                "business_impact": "medium",
                "affected_users": 5000
            },
            {
                "title": "Critical Remote Code Execution",
                "description": "Unauthenticated remote code execution in admin panel",
                "severity": VulnerabilitySeverity.CRITICAL,
                "cvss_score": 9.8,
                "category": VulnerabilityCategory.ACCESS_CONTROL,
                "cwe_id": "CWE-862",
                "target_name": "Admin Portal",
                "location": "https://admin.example.com/exec",
                "business_impact": "critical",
                "data_exposure_risk": True,
                "affected_users": 100
            },
            {
                "title": "Insecure Direct Object Reference",
                "description": "User can access other users' data by manipulating object references",
                "severity": VulnerabilitySeverity.HIGH,
                "cvss_score": 7.5,
                "category": VulnerabilityCategory.ACCESS_CONTROL,
                "cwe_id": "CWE-639",
                "target_name": "User Dashboard",
                "location": "https://app.example.com/user/profile",
                "business_impact": "high",
                "data_exposure_risk": True,
                "affected_users": 8000
            },
            {
                "title": "Missing Security Headers",
                "description": "Web application missing security headers (CSP, HSTS, etc.)",
                "severity": VulnerabilitySeverity.LOW,
                "cvss_score": 3.1,
                "category": VulnerabilityCategory.CONFIGURATION,
                "cwe_id": "CWE-16",
                "target_name": "Public Website",
                "location": "https://www.example.com",
                "business_impact": "low",
                "affected_users": 50000
            }
        ]

        print("üìã Discovering vulnerabilities...")

        for vuln_data in sample_vulns:
            # Create vulnerability object
            vuln = Vulnerability(
                title=vuln_data["title"],
                description=vuln_data["description"],
                severity=vuln_data["severity"],
                cvss_score=vuln_data["cvss_score"],
                category=vuln_data["category"],
                cwe_id=vuln_data.get("cwe_id"),
                target_name=vuln_data["target_name"],
                location=vuln_data["location"],
                business_impact=vuln_data["business_impact"],
                affected_users=vuln_data.get("affected_users", 0),
                data_exposure_risk=vuln_data.get("data_exposure_risk", False)
            )

            # Add evidence
            vuln.add_evidence(
                "scanner_output",
                "Vulnerability detected by automated scanner",
                source="xorb_scanner",
                confidence=0.9
            )

            # Add to vulnerability manager
            vuln_id = await vulnerability_manager.add_vulnerability(vuln)
            self.demo_vulnerabilities.append(vuln_id)

            print(f"   ‚Ä¢ {vuln.severity.value.upper()}: {vuln.title}")
            print(f"     ID: {vuln_id}, CVSS: {vuln.cvss_score}, Category: {vuln.category.value}")

        print(f"\n‚úÖ Discovered {len(sample_vulns)} vulnerabilities")

    async def _demo_automated_triage(self) -> None:
        """Demonstrate automated triage and workflow automation."""
        print("\n‚öôÔ∏è AUTOMATED TRIAGE DEMONSTRATION")
        print("-" * 50)

        print("ü§ñ Applying automated triage rules...")

        # Apply workflow rules to all vulnerabilities
        await vulnerability_manager._apply_workflow_rules()

        # Show triage results
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                print(f"   ‚Ä¢ {vuln.title[:50]}...")
                print(f"     State: {vuln.state.value}")
                print(f"     Priority: {vuln.remediation_priority.value}")
                if vuln.team:
                    print(f"     Assigned Team: {vuln.team}")
                print(f"     SLA Due: {time.strftime('%Y-%m-%d %H:%M', time.localtime(vuln.sla_due_date))}")

        print("\n‚úÖ Automated triage completed")

    async def _demo_remediation_workflow(self) -> None:
        """Demonstrate remediation workflow and automation."""
        print("\nüîß REMEDIATION WORKFLOW DEMONSTRATION")
        print("-" * 50)

        print("üìã Generating remediation steps...")

        # Show remediation steps for each vulnerability
        for vuln_id in self.demo_vulnerabilities[:3]:  # Show first 3 for brevity
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln and vuln.remediation_steps:
                print(f"\nüéØ {vuln.title}")
                print(f"   Remediation Steps ({len(vuln.remediation_steps)} total):")

                for i, step in enumerate(vuln.remediation_steps, 1):
                    print(f"   {i}. {step.title}")
                    print(f"      Type: {step.category}, Effort: {step.estimated_effort_hours}h")
                    if step.automated:
                        print("      ü§ñ Automated step")
                    if step.depends_on:
                        print(f"      Dependencies: {len(step.depends_on)} step(s)")

        print("\nü§ñ Executing automated remediation steps...")

        # Simulate automated remediation execution
        await vulnerability_manager._process_remediation_queue()

        # Show execution results
        automation_count = 0
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                for step in vuln.remediation_steps:
                    if step.automated and step.status == "completed":
                        automation_count += 1
                        print(f"   ‚úÖ Automated: {step.title}")

        print(f"\n‚úÖ Remediation workflow processed, {automation_count} automated steps executed")

    async def _demo_sla_management(self) -> None:
        """Demonstrate SLA tracking and violation management."""
        print("\n‚è∞ SLA MANAGEMENT DEMONSTRATION")
        print("-" * 50)

        # Simulate some SLA violations by manipulating discovery times
        critical_vuln = None
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln and vuln.severity == VulnerabilitySeverity.CRITICAL:
                critical_vuln = vuln
                break

        if critical_vuln:
            # Simulate an older critical vulnerability that would violate SLA
            original_time = critical_vuln.discovered_at
            critical_vuln.discovered_at = time.time() - (25 * 3600)  # 25 hours ago
            critical_vuln.sla_due_date = critical_vuln.discovered_at + (24 * 3600)  # 24 hour SLA

            print("üö® Simulating SLA violation scenario...")
            print(f"   Critical vulnerability: {critical_vuln.title}")
            print(f"   Discovered: {time.strftime('%Y-%m-%d %H:%M', time.localtime(critical_vuln.discovered_at))}")
            print(f"   SLA Due: {time.strftime('%Y-%m-%d %H:%M', time.localtime(critical_vuln.sla_due_date))}")
            print(f"   Age: {critical_vuln.get_age_days():.1f} days")

            # Check SLA violation
            if critical_vuln.is_sla_violated():
                print("   ‚ùå SLA VIOLATED")
            else:
                print("   ‚úÖ Within SLA")

            # Apply SLA escalation workflow
            await vulnerability_manager._apply_workflow_rules()

            if "sla_violated" in critical_vuln.tags:
                print("   üö® Automatically escalated due to SLA violation")

            # Restore original time
            critical_vuln.discovered_at = original_time
            critical_vuln.sla_due_date = critical_vuln._calculate_sla_due_date()

        # Show SLA status for all vulnerabilities
        print("\nüìä SLA Status Summary:")
        sla_violations = vulnerability_manager.get_sla_violations()
        print(f"   ‚Ä¢ SLA Violations: {len(sla_violations)}")

        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                time_remaining = (vuln.sla_due_date - time.time()) / 3600 if vuln.sla_due_date else 0
                status = "‚è∞ At Risk" if 0 < time_remaining < 24 else "‚úÖ OK" if time_remaining > 0 else "‚ùå Violated"
                print(f"   ‚Ä¢ {vuln.severity.value.upper()}: {status} ({time_remaining:.1f}h remaining)")

        print("\n‚úÖ SLA management demonstration completed")

    async def _demo_lifecycle_tracking(self) -> None:
        """Demonstrate vulnerability lifecycle state tracking."""
        print("\nüìä LIFECYCLE TRACKING DEMONSTRATION")
        print("-" * 50)

        print("üîÑ Simulating vulnerability lifecycle progression...")

        # Progress some vulnerabilities through different states
        state_progression = [
            (VulnerabilityState.TRIAGED, "Manual triage completed"),
            (VulnerabilityState.CONFIRMED, "Vulnerability confirmed by security team"),
            (VulnerabilityState.ASSIGNED, "Assigned to development team"),
            (VulnerabilityState.IN_PROGRESS, "Development team working on fix"),
            (VulnerabilityState.TESTING, "Fix implemented, testing in progress"),
            (VulnerabilityState.RESOLVED, "Fix deployed to production"),
            (VulnerabilityState.VERIFIED, "Fix verified by security team"),
            (VulnerabilityState.CLOSED, "Vulnerability lifecycle completed")
        ]

        # Progress first vulnerability through complete lifecycle
        if self.demo_vulnerabilities:
            vuln_id = self.demo_vulnerabilities[0]
            vuln = vulnerability_manager.get_vulnerability(vuln_id)

            print(f"\nüìà Progressing: {vuln.title}")

            for state, reason in state_progression:
                await vulnerability_manager.update_vulnerability_state(vuln_id, state, reason, "demo_user")
                print(f"   ‚Ä¢ {state.value}: {reason}")
                await asyncio.sleep(0.1)  # Small delay for demonstration

        # Progress second vulnerability partially
        if len(self.demo_vulnerabilities) > 1:
            vuln_id = self.demo_vulnerabilities[1]
            vuln = vulnerability_manager.get_vulnerability(vuln_id)

            print(f"\nüìà Partially progressing: {vuln.title}")

            for state, reason in state_progression[:4]:  # Only progress through first 4 states
                await vulnerability_manager.update_vulnerability_state(vuln_id, state, reason, "demo_user")
                print(f"   ‚Ä¢ {state.value}: {reason}")

        # Show state distribution
        print("\nüìä Current State Distribution:")
        by_state = {}
        for vuln_id in self.demo_vulnerabilities:
            vuln = vulnerability_manager.get_vulnerability(vuln_id)
            if vuln:
                state = vuln.state.value
                by_state[state] = by_state.get(state, 0) + 1

        for state, count in by_state.items():
            print(f"   ‚Ä¢ {state}: {count} vulnerabilities")

        print("\n‚úÖ Lifecycle tracking demonstration completed")

    async def _demo_reporting(self) -> None:
        """Demonstrate vulnerability reporting capabilities."""
        print("\nüìà REPORTING DEMONSTRATION")
        print("-" * 50)

        print("üìä Generating vulnerability reports...")

        # Get system statistics
        stats = vulnerability_manager.get_system_statistics()

        print("\nüìã System Overview:")
        print(f"   ‚Ä¢ Total Vulnerabilities: {stats['total_vulnerabilities']}")
        print(f"   ‚Ä¢ Active Vulnerabilities: {stats['active_vulnerabilities']}")
        print(f"   ‚Ä¢ Discovery Sources: {stats['discovery_sources']}")
        print(f"   ‚Ä¢ Remediation Providers: {stats['remediation_providers']}")
        print(f"   ‚Ä¢ Automated Remediations: {stats['remediations_automated']}")

        print("\nüéØ By Severity:")
        for severity, count in stats.get('by_severity', {}).items():
            print(f"   ‚Ä¢ {severity.upper()}: {count}")

        print("\nüìÇ By Category:")
        top_categories = sorted(stats.get('by_category', {}).items(), key=lambda x: x[1], reverse=True)[:5]
        for category, count in top_categories:
            print(f"   ‚Ä¢ {category.replace('_', ' ').title()}: {count}")

        print("\nüîÑ By State:")
        for state, count in stats.get('by_state', {}).items():
            print(f"   ‚Ä¢ {state.replace('_', ' ').title()}: {count}")

        # Generate detailed report
        report = await vulnerability_manager.generate_vulnerability_report(timeframe_hours=24)

        print("\nüìà 24-Hour Activity Report:")
        print(f"   ‚Ä¢ New Discoveries: {report['summary']['total_discovered']}")
        print(f"   ‚Ä¢ Critical: {report['summary']['critical']}")
        print(f"   ‚Ä¢ High: {report['summary']['high']}")
        print(f"   ‚Ä¢ Medium: {report['summary']['medium']}")
        print(f"   ‚Ä¢ Low: {report['summary']['low']}")

        print("\nüîß Remediation Progress:")
        progress = report['remediation_progress']
        print(f"   ‚Ä¢ Resolved: {progress['resolved']}")
        print(f"   ‚Ä¢ In Progress: {progress['in_progress']}")
        print(f"   ‚Ä¢ Pending: {progress['pending']}")

        print("\n‚è∞ SLA Status:")
        sla_status = report['sla_status']
        print(f"   ‚Ä¢ Violations: {sla_status['violations']}")
        print(f"   ‚Ä¢ At Risk: {sla_status['at_risk']}")

        print("\n‚úÖ Reporting demonstration completed")

    async def _generate_summary_report(self) -> None:
        """Generate comprehensive summary report."""
        print("\nüìä COMPREHENSIVE SUMMARY REPORT")
        print("=" * 50)

        stats = vulnerability_manager.get_system_statistics()

        print("üéØ Vulnerability Management System Summary:")
        print(f"   ‚Ä¢ Vulnerabilities Processed: {stats['vulnerabilities_processed']}")
        print(f"   ‚Ä¢ Automated Remediations: {stats['remediations_automated']}")
        print(f"   ‚Ä¢ SLA Violations: {stats['sla_violations']}")
        print(f"   ‚Ä¢ False Positives: {stats['false_positives']}")

        print("\nüîß System Capabilities:")
        print("   ‚Ä¢ ‚úÖ Automated vulnerability discovery and classification")
        print("   ‚Ä¢ ‚úÖ Intelligent triage and workflow automation")
        print("   ‚Ä¢ ‚úÖ Remediation step generation and tracking")
        print("   ‚Ä¢ ‚úÖ SLA management and violation detection")
        print("   ‚Ä¢ ‚úÖ Complete lifecycle state management")
        print("   ‚Ä¢ ‚úÖ Comprehensive reporting and analytics")

        print("\nüìà Business Value:")
        print("   ‚Ä¢ Reduced manual triage effort through automation")
        print("   ‚Ä¢ Improved remediation tracking and accountability")
        print("   ‚Ä¢ Proactive SLA violation prevention")
        print("   ‚Ä¢ Enhanced visibility into vulnerability landscape")
        print("   ‚Ä¢ Streamlined security team workflows")

        print("\n‚úÖ VULNERABILITY LIFECYCLE MANAGEMENT DEMONSTRATION COMPLETE")
        print("All advanced vulnerability management capabilities successfully demonstrated!")

    async def _cleanup_system(self) -> None:
        """Clean up the demonstration system."""
        print("\nüßπ Cleaning up demonstration...")
        vulnerability_manager.running = False
        print("‚úÖ Cleanup completed")


async def main() -> None:
    """Main demonstration function."""
    demo = VulnerabilityLifecycleDemo()
    await demo.run_demo()


if __name__ == "__main__":
    asyncio.run(main())
