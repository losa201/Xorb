apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: epyc-cpu-governor-optimizer
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
    xorb.ai/optimization-target: epyc-7702
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: epyc-cpu-governor
  template:
    metadata:
      labels:
        app.kubernetes.io/name: epyc-cpu-governor
        app.kubernetes.io/component: system-optimization
        app.kubernetes.io/part-of: xorb
        xorb.ai/optimization-target: epyc-7702
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9100"
        prometheus.io/path: "/metrics"
    spec:
      hostNetwork: true
      hostPID: true
      hostIPC: true
      tolerations:
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: xorb.ai/dedicated
        operator: Exists
        effect: NoSchedule
      nodeSelector:
        kubernetes.io/arch: amd64
        node.kubernetes.io/cpu-family: "EPYC"
        xorb.ai/optimized-for: epyc-7702
      serviceAccountName: epyc-system-optimizer
      priorityClassName: system-node-critical
      containers:
      - name: cpu-governor-optimizer
        image: alpine:3.18
        command:
        - /bin/sh
        - -c
        - |
          set -euo pipefail
          
          echo "Starting EPYC CPU Governor Optimizer..."
          echo "Hostname: $(hostname)"
          echo "CPU Info:"
          cat /proc/cpuinfo | grep -E "(model name|processor|cpu cores|siblings)" | head -20
          
          # Function to log with timestamp
          log() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
          }
          
          # Function to apply CPU governor settings
          apply_governor_settings() {
              local governor="$1"
              local description="$2"
              
              log "Applying $description governor settings..."
              
              # Set CPU governor for all cores
              for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
                  if [ -w "$cpu" ]; then
                      echo "$governor" > "$cpu" 2>/dev/null || log "Warning: Could not set governor for $cpu"
                  fi
              done
              
              # Verify governor was set
              current_governor=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null || echo "unknown")
              log "Current governor: $current_governor"
          }
          
          # Function to apply EPYC-specific optimizations
          apply_epyc_optimizations() {
              log "Applying EPYC-specific CPU optimizations..."
              
              # Disable CPU boost for consistent performance (optional)
              if [ -w /sys/devices/system/cpu/cpufreq/boost ]; then
                  echo 0 > /sys/devices/system/cpu/cpufreq/boost
                  log "CPU boost disabled for consistent performance"
              fi
              
              # Set CPU frequency scaling settings for EPYC
              for cpu_dir in /sys/devices/system/cpu/cpu*/cpufreq/; do
                  if [ -d "$cpu_dir" ]; then
                      # Set frequency scaling settings
                      if [ -w "${cpu_dir}scaling_min_freq" ] && [ -w "${cpu_dir}scaling_max_freq" ]; then
                          # Get available frequencies
                          if [ -r "${cpu_dir}scaling_available_frequencies" ]; then
                              available_freqs=$(cat "${cpu_dir}scaling_available_frequencies")
                              min_freq=$(echo $available_freqs | awk '{print $NF}')  # Last (lowest)
                              max_freq=$(echo $available_freqs | awk '{print $1}')   # First (highest)
                              
                              # For EPYC 7702: typically 2000-3350 MHz
                              # Set min to base frequency (2000 MHz) for power efficiency
                              echo "$min_freq" > "${cpu_dir}scaling_min_freq" 2>/dev/null || true
                              # Set max to allow boost when needed
                              echo "$max_freq" > "${cpu_dir}scaling_max_freq" 2>/dev/null || true
                          fi
                      fi
                      
                      # Set performance bias (0 = performance, 15 = power save)
                      if [ -w "${cpu_dir}energy_performance_preference" ]; then
                          echo "performance" > "${cpu_dir}energy_performance_preference" 2>/dev/null || true
                      fi
                  fi
              done
              
              # Apply NUMA balancing settings
              if [ -w /proc/sys/kernel/numa_balancing ]; then
                  echo 1 > /proc/sys/kernel/numa_balancing
                  log "NUMA balancing enabled"
              fi
              
              # Optimize scheduler for EPYC's CCX topology
              if [ -w /proc/sys/kernel/sched_migration_cost_ns ]; then
                  echo 5000000 > /proc/sys/kernel/sched_migration_cost_ns
                  log "Scheduler migration cost optimized for EPYC CCX"
              fi
              
              # Set CPU idle governor for better power management
              if [ -w /sys/devices/system/cpu/cpuidle/current_governor ]; then
                  echo "menu" > /sys/devices/system/cpu/cpuidle/current_governor 2>/dev/null || true
                  log "CPU idle governor set to menu"
              fi
          }
          
          # Function to monitor and adjust based on workload
          monitor_and_adjust() {
              while true; do
                  # Get current CPU utilization
                  cpu_usage=$(awk '{u=$2+$4; t=$2+$4+$5; if (NR==1){u1=u; t1=t;} else print ($2+$4-u1) * 100 / (t-t1) "%"; }' \
                              <(grep 'cpu ' /proc/stat) <(sleep 1;grep 'cpu ' /proc/stat) | head -1 | sed 's/%//')
                  
                  cpu_usage_int=$(echo "$cpu_usage" | cut -d. -f1)
                  
                  log "Current CPU usage: ${cpu_usage}%"
                  
                  # Adjust governor based on load
                  if [ "$cpu_usage_int" -gt 80 ]; then
                      # High load: use performance governor
                      current_gov=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null)
                      if [ "$current_gov" != "performance" ]; then
                          apply_governor_settings "performance" "High Load Performance"
                      fi
                  elif [ "$cpu_usage_int" -lt 30 ]; then
                      # Low load: use powersave for efficiency
                      current_gov=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null)
                      if [ "$current_gov" != "powersave" ]; then
                          apply_governor_settings "powersave" "Low Load Power Save"
                      fi
                  else
                      # Medium load: use ondemand for balance
                      current_gov=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null)
                      if [ "$current_gov" != "ondemand" ]; then
                          apply_governor_settings "ondemand" "Balanced On-Demand"
                      fi
                  fi
                  
                  # Sleep for monitoring interval
                  sleep 30
              done
          }
          
          # Function to expose metrics for Prometheus
          start_metrics_server() {
              log "Starting metrics server on port 9100..."
              
              while true; do
                  # Create metrics in Prometheus format
                  cat > /tmp/metrics.prom << EOF
          # HELP epyc_cpu_governor_current Current CPU governor setting
          # TYPE epyc_cpu_governor_current gauge
          epyc_cpu_governor_current{governor="$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null || echo unknown)"} 1
          
          # HELP epyc_cpu_frequency_current_hz Current CPU frequency in Hz
          # TYPE epyc_cpu_frequency_current_hz gauge
          epyc_cpu_frequency_current_hz $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq 2>/dev/null | awk '{print $1 * 1000}' || echo 0)
          
          # HELP epyc_cpu_boost_enabled CPU boost enabled status
          # TYPE epyc_cpu_boost_enabled gauge
          epyc_cpu_boost_enabled $(cat /sys/devices/system/cpu/cpufreq/boost 2>/dev/null || echo 0)
          
          # HELP epyc_numa_balancing_enabled NUMA balancing enabled status
          # TYPE epyc_numa_balancing_enabled gauge
          epyc_numa_balancing_enabled $(cat /proc/sys/kernel/numa_balancing 2>/dev/null || echo 0)
          
          # HELP epyc_cpu_cores_total Total number of CPU cores
          # TYPE epyc_cpu_cores_total gauge
          epyc_cpu_cores_total $(nproc)
          
          # HELP epyc_optimization_timestamp_seconds Timestamp of last optimization
          # TYPE epyc_optimization_timestamp_seconds gauge
          epyc_optimization_timestamp_seconds $(date +%s)
          EOF
                  
                  sleep 15
              done &
              
              # Simple HTTP server for metrics
              while true; do
                  { echo -e "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n"; cat /tmp/metrics.prom 2>/dev/null || echo "# metrics not ready"; } | nc -l -p 9100
              done
          }
          
          # Main execution
          log "EPYC CPU Governor Optimizer starting..."
          
          # Check if we're running on EPYC
          cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | grep -i epyc || echo "")
          if [ -z "$cpu_model" ]; then
              log "Warning: Not running on EPYC processor. Optimization may not be optimal."
          else
              log "Detected EPYC processor: $cpu_model"
          fi
          
          # Apply initial optimizations
          apply_epyc_optimizations
          
          # Set initial governor based on current load
          cpu_usage=$(awk '{u=$2+$4; t=$2+$4+$5; if (NR==1){u1=u; t1=t;} else print ($2+$4-u1) * 100 / (t-t1) "%"; }' \
                      <(grep 'cpu ' /proc/stat) <(sleep 1;grep 'cpu ' /proc/stat) | head -1 | sed 's/%//')
          cpu_usage_int=$(echo "$cpu_usage" | cut -d. -f1)
          
          if [ "$cpu_usage_int" -gt 50 ]; then
              apply_governor_settings "performance" "Initial High Performance"
          else
              apply_governor_settings "ondemand" "Initial Balanced"
          fi
          
          # Start metrics writer in background
          write_metrics_file &
          
          # Start monitoring and adjustment loop
          log "Starting continuous monitoring and optimization..."
          monitor_and_adjust
        securityContext:
          privileged: true
          runAsUser: 0
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 128Mi
        volumeMounts:
        - name: sys
          mountPath: /sys
        - name: proc
          mountPath: /proc
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        ports:
        - name: metrics
          containerPort: 9100
          protocol: TCP
# Health probes disabled for initial deployment
        # livenessProbe:
        #   exec:
        #     command:
        #     - /bin/sh
        #     - -c
        #     - "ps aux | grep -v grep | grep 'monitor_and_adjust'"
        #   initialDelaySeconds: 60
        #   periodSeconds: 30
      volumes:
      - name: sys
        hostPath:
          path: /sys
          type: Directory
      - name: proc
        hostPath:
          path: /proc
          type: Directory
      terminationGracePeriodSeconds: 30
      dnsPolicy: ClusterFirst
      restartPolicy: Always
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: epyc-system-optimizer
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: epyc-system-optimizer
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["metrics.k8s.io"]
  resources: ["nodes", "pods"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: epyc-system-optimizer
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: epyc-system-optimizer
subjects:
- kind: ServiceAccount
  name: epyc-system-optimizer
  namespace: xorb-prod
---
apiVersion: v1
kind: Service
metadata:
  name: epyc-cpu-governor-metrics
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9100"
    prometheus.io/path: "/metrics"
spec:
  type: ClusterIP
  clusterIP: None  # Headless service for DaemonSet
  selector:
    app.kubernetes.io/name: epyc-cpu-governor
  ports:
  - name: metrics
    port: 9100
    targetPort: 9100
    protocol: TCP
# ServiceMonitor commented out - requires Prometheus Operator CRD
# Uncomment when Prometheus Operator is installed
#---
#apiVersion: monitoring.coreos.com/v1
#kind: ServiceMonitor
#metadata:
#  name: epyc-cpu-governor
#  namespace: xorb-prod
#  labels:
#    app.kubernetes.io/name: epyc-cpu-governor
#    app.kubernetes.io/component: system-optimization
#    app.kubernetes.io/part-of: xorb
#    prometheus: kube-prometheus
#spec:
#  selector:
#    matchLabels:
#      app.kubernetes.io/name: epyc-cpu-governor
#  endpoints:
#  - port: metrics
#    interval: 30s
#    path: /
#    scrapeTimeout: 10s
#    relabelings:
#    - sourceLabels: [__meta_kubernetes_pod_node_name]
#      targetLabel: node
#    - sourceLabels: [__meta_kubernetes_pod_name]
#      targetLabel: pod
#    - sourceLabels: [__meta_kubernetes_namespace]
#      targetLabel: namespace
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: epyc-cpu-governor-pdb
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
spec:
  minAvailable: 50%
  selector:
    matchLabels:
      app.kubernetes.io/name: epyc-cpu-governor
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: epyc-optimization-config
  namespace: xorb-prod
  labels:
    app.kubernetes.io/name: epyc-cpu-governor
    app.kubernetes.io/component: system-optimization
    app.kubernetes.io/part-of: xorb
data:
  epyc-7702-specs.yaml: |
    # AMD EPYC 7702 Specifications and Optimization Parameters
    processor:
      model: "AMD EPYC 7702"
      architecture: "Zen 2"
      cores: 64
      threads: 128
      base_frequency_mhz: 2000
      max_boost_frequency_mhz: 3350
      l1_cache_kb: 64  # 32KB I + 32KB D per core
      l2_cache_kb: 512  # 512KB per core
      l3_cache_mb: 256  # 256MB total (32MB per CCX, 8 CCX)
      
    numa:
      nodes: 2
      cores_per_node: 32
      threads_per_node: 64
      memory_channels_per_node: 8
      
    ccx:  # Core Complex
      count: 8
      cores_per_ccx: 4
      threads_per_ccx: 8
      l3_cache_mb_per_ccx: 32
      
    optimization:
      governor_high_load: "performance"
      governor_medium_load: "ondemand"
      governor_low_load: "powersave"
      cpu_boost_default: false  # Disable for consistent performance
      numa_balancing: true
      scheduler_migration_cost_ns: 5000000  # 5ms for CCX topology
      
    thresholds:
      high_load_percent: 80
      medium_load_percent: 30
      temperature_warning_celsius: 75
      temperature_critical_celsius: 85
      
    monitoring:
      check_interval_seconds: 30
      metrics_port: 9100
      
  optimization-profiles.yaml: |
    # Different optimization profiles for various workloads
    profiles:
      ai_training:
        description: "Optimized for AI/ML training workloads"
        governor: "performance"
        cpu_boost: false
        numa_balancing: true
        scheduler_policy: "batch"
        
      web_services:
        description: "Optimized for web service workloads"
        governor: "ondemand"
        cpu_boost: true
        numa_balancing: true
        scheduler_policy: "normal"
        
      batch_processing:
        description: "Optimized for batch processing"
        governor: "powersave"
        cpu_boost: false
        numa_balancing: false
        scheduler_policy: "batch"
        
      real_time:
        description: "Optimized for real-time workloads"
        governor: "performance"
        cpu_boost: false
        numa_balancing: false
        scheduler_policy: "fifo"
        cpu_isolation: true